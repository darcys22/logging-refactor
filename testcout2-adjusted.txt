// Copyright (c) 2014-2019, The Monero Project
// Copyright (c)      2018, The Loki Project
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without modification, are
// permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this list of
//    conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice, this list
//    of conditions and the following disclaimer in the documentation and/or other
//    materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its contributors may be
//    used to endorse or promote products derived from this software without specific
//    prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Parts of this file are originally copyright (c) 2012-2013 The Cryptonote developers

#include <algorithm>
#include <chrono>
#include <cstdio>
#include <oxenc/endian.h>
#include <sodium.h>

#include "common/rules.h"
#include "common/hex.h"
#include "common/median.h"
#include "cryptonote_basic/cryptonote_basic.h"
#include "cryptonote_basic/cryptonote_basic_impl.h"
#include "cryptonote_basic/hardfork.h"
#include "cryptonote_core/cryptonote_tx_utils.h"
#include "ringct/rctTypes.h"
#include "tx_pool.h"
#include "blockchain.h"
#include "blockchain_db/blockchain_db.h"
#include "cryptonote_basic/cryptonote_boost_serialization.h"
#include "cryptonote_config.h"
#include "cryptonote_basic/miner.h"
#include "epee/profile_tools.h"
#include "epee/int-util.h"
#include "common/threadpool.h"
#include "common/boost_serialization_helper.h"
#include "epee/warnings.h"
#include "crypto/hash.h"
#include "cryptonote_core.h"
#include "ringct/rctSigs.h"
#include "common/perf_timer.h"
#include "common/notify.h"
#include "service_node_voting.h"
#include "service_node_list.h"
#include "common/varint.h"
#include "common/pruning.h"
#include "common/lock.h"
#include "common/meta.h"
#include "common/sha256sum.h"

#ifdef ENABLE_SYSTEMD
extern "C" {
#  include <systemd/sd-daemon.h>
}
#endif

#undef OXEN_DEFAULT_LOG_CATEGORY
#define OXEN_DEFAULT_LOG_CATEGORY "blockchain"

#define FIND_BLOCKCHAIN_SUPPLEMENT_MAX_SIZE (100*1024*1024) // 100 MB

using namespace crypto;

//#include "serialization/json_archive.h"

/* TODO:
 *  Clean up code:
 *    Possibly change how outputs are referred to/indexed in blockchain and wallets
 *
 */

using namespace cryptonote;

DISABLE_VS_WARNINGS(4267)

#define MERROR_VER(x) MCERROR("verify", x)

// used to overestimate the block reward when estimating a per kB to use
#define BLOCK_REWARD_OVERESTIMATE (10 * 1000000000000)

Blockchain::block_extended_info::block_extended_info(const alt_block_data_t &src, block const &blk, checkpoint_t const *checkpoint)
{
  assert((src.checkpointed) == (checkpoint != nullptr));
  *this                         = {};
  this->bl                      = blk;
  this->checkpointed            = src.checkpointed;
  if (checkpoint) this->checkpoint = *checkpoint;
  this->height                  = src.height;
  this->block_cumulative_weight = src.cumulative_weight;
  this->cumulative_difficulty   = src.cumulative_difficulty;
  this->already_generated_coins = src.already_generated_coins;
}

//------------------------------------------------------------------
Blockchain::Blockchain(tx_memory_pool& tx_pool, service_nodes::service_node_list& service_node_list):
  m_db(), m_tx_pool(tx_pool), m_current_block_cumul_weight_limit(0), m_current_block_cumul_weight_median(0),
  m_max_prepare_blocks_threads(4), m_db_sync_on_blocks(true), m_db_sync_threshold(1), m_db_sync_mode(db_async), m_db_default_sync(false), m_fast_sync(true), m_show_time_stats(false), m_sync_counter(0), m_bytes_to_sync(0), m_cancel(false),
  m_long_term_block_weights_window(LONG_TERM_BLOCK_WEIGHT_WINDOW_SIZE),
  m_long_term_effective_median_block_weight(0),
  m_long_term_block_weights_cache_tip_hash(crypto::null_hash),
  m_long_term_block_weights_cache_rolling_median(LONG_TERM_BLOCK_WEIGHT_WINDOW_SIZE),
  m_service_node_list(service_node_list),
  m_btc_valid(false),
  m_batch_success(true),
  m_prepare_height(0)
{
  OXEN_LOG(trace, "Blockchain::" << __func__);
}
//------------------------------------------------------------------
Blockchain::~Blockchain()
{
  try { deinit(); }
  catch (const std::exception &e) { /* ignore */ }
}
//------------------------------------------------------------------
bool Blockchain::have_tx(const crypto::hash &id) const
{
  OXEN_LOG(trace, "Blockchain::" << __func__);
  // WARNING: this function does not take m_blockchain_lock, and thus should only call read only
  // m_db functions which do not depend on one another (ie, no getheight + gethash(height-1), as
  // well as not accessing class members, even read only (ie, m_invalid_blocks). The caller must
  // lock if it is otherwise needed.
  return m_db->tx_exists(id);
}
//------------------------------------------------------------------
bool Blockchain::have_tx_keyimg_as_spent(const crypto::key_image &key_im) const
{
  OXEN_LOG(trace, "Blockchain::" << __func__);
  // WARNING: this function does not take m_blockchain_lock, and thus should only call read only
OXEN_LOG(error, "Wrong log level: " << el::LevelHelper::convertToString(level) << ", using Info");
OXEN_LOG(err, "Field " << #name << " found in JSON, but not " << #jtype); \
OXEN_LOG(err, "Field " << #name << " not found in JSON"); \
OXEN_LOG(error, "Error locking fd " << fd << ": " << errno << " (" << strerror(errno) << ")");
OXEN_LOG(error, "Failed to lock " << filename << ": " << std::error_code(GetLastError(), std::system_category()));
OXEN_LOG(error, "Failed to open " << filename << ": " << std::error_code(GetLastError(), std::system_category()));
OXEN_LOG(error, "Failed to lock " << filename << ": " << std::strerror(errno));
OXEN_LOG(error, "Failed to open " << filename << ": " << std::strerror(errno));
OXEN_LOG(error, "CreateProcess failed. Error code " << GetLastError());
OXEN_LOG(error, "WaitForSingleObject failed. Result " << result << ", error code " << GetLastError());
OXEN_LOG(error, "GetExitCodeProcess failed. Error code " << GetLastError());
OXEN_LOG(info, "Child exited with " << exitCode);
OXEN_LOG(error, "Error forking: " << strerror(errno));
OXEN_LOG(error, "Failed to execve: " << strerror(errno));
OXEN_LOG(error, "Error waiting for child: " << strerror(errno));
OXEN_LOG(info, "Child exited with " << WEXITSTATUS(wstatus));
OXEN_LOG(info, "Child killed by " << WEXITSTATUS(wstatus));
OXEN_LOG(error, "Invalid max connections given to --" << arg_tx_proxy.name);
OXEN_LOG(error, "Too many ',' characters given to --" << arg_tx_proxy.name);
OXEN_LOG(error, "Invalid network for --" << arg_tx_proxy.name);
OXEN_LOG(error, "Invalid ipv4:port given for --" << arg_tx_proxy.name);
OXEN_LOG(error, "Invalid max connections given to --" << arg_tx_proxy.name);
OXEN_LOG(error, "Invalid inbound address (" << address << ") for --" << arg_anonymous_inbound.name << ": " << (our_address ? "invalid type" : our_address.error().message()));
OXEN_LOG(error, "Invalid ipv4:port given for --" << arg_anonymous_inbound.name);
OXEN_LOG(warn, "Filtered command (#" << command << ") to/from " << address.str());
OXEN_LOG(error, "Timeout on socks connect (" << proxy << " to " << remote.str() << ")");
OXEN_LOG(error, "Failed to make socks connection to " << remote.str() << " (via " << proxy << "): " << result.first.message());
OXEN_LOG(debug, "Block queue has " << blocks.size() << " spans");
OXEN_LOG(debug, "  " << span.start_block_height << " - " << (span.start_block_height+span.nblocks-1) << " (" << span.nblocks << ") - " << (span.blocks.empty() ? "scheduled" : "filled    ") << "  " << span.connection_id << " (" << ((unsigned)(span.rate*10/1024.f))/10.f << " kB/s)");
OXEN_LOG(debug, "reserve_span: first_block_height " << first_block_height << ", last_block_height " << last_block_height
OXEN_LOG(debug, "reserve_span: early out: first_block_height " << first_block_height << ", last_block_height " << last_block_height << ", max_blocks " << max_blocks);
OXEN_LOG(debug, "reserve_span: more block hashes than fit within last_block_height: " << block_hashes.size() << " and " << last_block_height);
OXEN_LOG(debug, "reserve_span: next_unpruned_height " << next_unpruned_height << " from " << span_start_height << " and seed "
OXEN_LOG(debug, "We can download from next span: ideal height " << span_start_height << ", next unpruned height " << next_unpruned_height <<
OXEN_LOG(debug, "span_start_height: " <<span_start_height);
OXEN_LOG(debug, "Reserving span " << span_start_height << " - " << (span_start_height + span_length - 1) << " for " << connection_id);
OXEN_LOG(trace, " Relative speed for " << connection_id << ": " << speed << " (" << conn_rate << "/" << best_rate);
OXEN_LOG(trace, "Download rate for " << connection_id << ": " << conn_rate << " b/s");
OXEN_LOG(debug, "Have " << candidates.size() << " SN candidates");
OXEN_LOG(trace, "Not include inactive node " << pubkey);
OXEN_LOG(trace, "Not including node " << pubkey << ": missing x25519(" << to_hex(get_data_as_string(proof.pubkey_x25519)) << "), "
OXEN_LOG(debug, "Have " << remotes.size() << " candidates after checking active status and connection details");
OXEN_LOG(info, "Relaying data to " << to_hex(x25519_string) << " @ " << connect_string);
OXEN_LOG(trace, "Not in subquorum " << (i == 0 ? "Q" : "Q'"));
OXEN_LOG(trace, "I am in subquorum " << (i == 0 ? "Q" : "Q'") << " position " << my_position[i]);
OXEN_LOG(trace, "Relaying within subquorum " << (i == 0 ? "Q" : "Q'") << "[" << my_position[i] << "] to [" << j << "] " << validators[j]);
OXEN_LOG(trace, "Optional opportunistic relay within quorum " << (i == 0 ? "Q" : "Q'") << "[" << my_position[i] << "] to [" << j << "] " << validators[j]);
OXEN_LOG(trace, "Inter-quorum relay from Q[" << my_position[i] << "] (me) to Q'[" << next_pos << "] = " << next_validators[next_pos]
OXEN_LOG(trace, "Q[" << my_position[i] << "] is not a Q -> Q' inter-quorum relay position");
OXEN_LOG(trace, "Not doing inter-quorum relaying because I am in both quorums (Q[" << my_position[i] << "], Q'[" << my_position[i+1] << "])");
OXEN_LOG(trace, "Inter-quorum relay from Q'[" << my_position[i] << "] (me) to Q[" << prev_pos << "] = " << prev_validators[prev_pos]
OXEN_LOG(trace, "Q'[" << my_position[i] << "] is not a Q' -> Q inter-quorum relay position");
OXEN_LOG(trace, "Not doing inter-quorum relaying because I am in both quorums (Q[" << my_position[i-1] << "], Q'[" << my_position[i] << "])");
OXEN_LOG(trace, "Relaying " << cmd << " to peer " << to_hex(peer.first) << (peer.second.empty() ? " (if connected)"s : " @ " + peer.second));
OXEN_LOG(debug, "Starting relay of " << votes.size() << " votes");
OXEN_LOG(error, "Internal logic error: quorumnet asked to relay a " << vote.type << " vote, but should only be called with obligations votes");
OXEN_LOG(warn, "Unable to relay vote: no " << vote.type << " quorum available for height " << vote.block_height);
OXEN_LOG(warn, "Invalid vote relay: " << vote.type << " quorum @ height " << vote.block_height <<
OXEN_LOG(debug, "Relayed " << relayed_votes.size() << " votes");
OXEN_LOG(debug, "Received a relayed obligation vote from " << to_hex(m.conn.pubkey()));
OXEN_LOG(info, "Ignoring vote: expected 1 data part, not " << m.data.size());
OXEN_LOG(debug, "Ignoring vote: block height " << vote.block_height << " is too high");
OXEN_LOG(warn, "Deserialization of vote from " << to_hex(m.conn.pubkey()) << " failed: " << e.what());
bool Blockchain::is_within_compiled_block_hash_area(uint64_t height) const
{
#if defined(PER_BLOCK_CHECKPOINT)
  return height < m_blocks_hash_of_hashes.size() * HASH_OF_HASHES_STEP;
#else
  return false;
#endif
}

bool Blockchain::for_all_key_images(std::function<bool(const crypto::key_image&)> f) const
{
  return m_db->for_all_key_images(f);
}

bool Blockchain::for_blocks_range(const uint64_t& h1, const uint64_t& h2, std::function<bool(uint64_t, const crypto::hash&, const block&)> f) const
{
  return m_db->for_blocks_range(h1, h2, f);
}

bool Blockchain::for_all_transactions(std::function<bool(const crypto::hash&, const cryptonote::transaction&)> f, bool pruned) const
{
  return m_db->for_all_transactions(f, pruned);
}

bool Blockchain::for_all_outputs(std::function<bool(uint64_t amount, const crypto::hash &tx_hash, uint64_t height, size_t tx_idx)> f) const
{
  return m_db->for_all_outputs(f);
}

bool Blockchain::for_all_outputs(uint64_t amount, std::function<bool(uint64_t height)> f) const
{
  return m_db->for_all_outputs(amount, f);
}

void Blockchain::invalidate_block_template_cache()
{
  OXEN_LOG(debug, "Invalidating block template cache");
  m_btc_valid = false;
}

void Blockchain::cache_block_template(const block &b, const cryptonote::account_public_address &address, const std::string &nonce, const difficulty_type &diff, uint64_t height, uint64_t expected_reward, uint64_t pool_cookie)
{
  OXEN_LOG(debug, "Setting block template cache");
  m_btc = b;
  m_btc_address = address;
  m_btc_nonce = nonce;
  m_btc_height = height;
  m_btc_expected_reward = expected_reward;
  m_btc_pool_cookie = pool_cookie;
  m_btc_valid = true;
}
OXEN_LOG(debug, "Received a timestamp request from " << to_hex(m.conn.pubkey()));
OXEN_LOG(trace, "Verified enough active blink nodes for a quorum; quorum checksum: " << local_checksum);
OXEN_LOG(trace, "Before recording new signatures I have existing signatures: " << debug_known_signatures(btx, blink_quorums));
OXEN_LOG(debug, "Validated and stored " << (approval ? "approval" : "rejection") << " signature for tx " << btx.get_txhash() << ", subquorum " << int{qi} << ", position " << position);
OXEN_LOG(debug, "Updated signatures; now have signatures: " << debug_known_signatures(btx, blink_quorums));
OXEN_LOG(debug, "Relaying " << signatures.size() << " blink signatures to " << pinfo.strong_peers << " (strong) + " <<
OXEN_LOG(debug, "Received a blink tx from " << (m.conn.sn() ? "SN " : "non-SN ") << to_hex(m.conn.pubkey()));
OXEN_LOG(info, "Rejecting blink message: expected one data entry not " << m.data.size());
OXEN_LOG(warn, "Rejecting blink message: blink is not available for hardfork " << (int) hf_version);
OXEN_LOG(info, "Rejecting blink tx because blink auth height is too low (" << blink_height << " vs. " << local_height << ")");
OXEN_LOG(info, "Rejecting blink tx because blink auth height is too high (" << blink_height << " vs. " << local_height << ")");
OXEN_LOG(trace, "Blink tx auth height " << blink_height << " is valid (local height is " << local_height << ")");
OXEN_LOG(trace, "Blink tx data is " << tx_data.size() << " bytes");
OXEN_LOG(info, "Submitted blink tx already " << (already_approved ? "approved" : "rejected") <<
OXEN_LOG(trace, "Blink tx hash: " << to_hex(tx_hash.data));
OXEN_LOG(info, "Rejecting blink tx: " << e.what());
OXEN_LOG(trace, "Found this SN in " << pinfo.my_position_count << " subquorums");
OXEN_LOG(info, "Rejecting blink tx: submitted tx hash " << tx_hash << " did not match actual tx hash " << tx_hash_actual);
OXEN_LOG(debug, "Relaying blink tx to " << pinfo.strong_peers << " strong and " << (pinfo.peers.size() - pinfo.strong_peers) << " opportunistic blink peers");
OXEN_LOG(info, "Blink TX " << tx_hash << " rejected because TX version " << tx.version << " invalid: TX version not between " << min << " and " << max);
OXEN_LOG(info, "Blink TX " << tx_hash << (approved ? " approved and added to mempool" : " rejected"));
OXEN_LOG(debug, "TX rejected because: " << print_tx_verification_context(tvc));
OXEN_LOG(debug, "Received a blink tx signature from SN " << to_hex(m.conn.pubkey()));
OXEN_LOG(error, "Bad blink not started response: expected one data entry not " << m.data.size());
OXEN_LOG(info, "Received no-start blink response: " << error);
OXEN_LOG(error, "Blink failure message not understood: expected one data entry not " << m.data.size());
OXEN_LOG(error, "Blink success message not understood: expected one data entry not " << m.data.size());
OXEN_LOG(debug, "[" << epee::net_utils::print_connection_context_short(exclude_context) << "] post relay " << tools::type_name<T>() << " -->");
OXEN_LOG(debug, "[" << epee::net_utils::print_connection_context_short(context) << "] post " << tools::type_name<t_parameter>() << " -->");
OXEN_LOG(err, "Serialization of " << tools::type_name(typeid(T)) << " failed: " << e.what());
OXEN_LOG(err, "obj_to_json_str failed: serialization failed: " << e.what());
OXEN_LOG(error, "Block cumulative weight is too big: " << current_block_weight << ", expected less than " << 2 * median_weight);
OXEN_LOG(info, "Wrong address prefix: " << prefix << ", expected " << address_prefix 
OXEN_LOG(info, "Failed to parse transaction from blob, bad outPk size in tx " << get_transaction_hash(tx));
OXEN_LOG(info, "Unsupported output type in tx " << get_transaction_hash(tx));
OXEN_LOG(info, "Failed to parse transaction from blob, bad bulletproofs size in tx " << get_transaction_hash(tx));
OXEN_LOG(info, "Failed to parse transaction from blob, bad bulletproofs L size in tx " << get_transaction_hash(tx));
OXEN_LOG(info, "Failed to parse transaction from blob, bad bulletproofs max outputs in tx " << get_transaction_hash(tx));
OXEN_LOG(err, "Failed to parse and validate transaction from blob: " << e.what());
OXEN_LOG(err, "Failed to parse transaction base from blob: " << e.what());
OXEN_LOG(err, "Failed to parse transaction prefix from blob: " << e.what());
OXEN_LOG(err, "Failed to parse and validate transaction from blob + hash: " << e.what());
OXEN_LOG(warn, "key image helper: failed to generate_key_derivation(" << tx_public_key << ", " << ack.m_view_secret_key << ")");
OXEN_LOG(warn, "key image helper: failed to generate_key_derivation(" << additional_tx_public_keys[i] << ", " << ack.m_view_secret_key << ")");
OXEN_LOG(warn, __func__ << ": failed to deserialize extra field: " << e.what() << "; extra = " << oxenc::to_hex(tx_extra.begin(), tx_extra.end()));
OXEN_LOG(info, "failed to serialize tx extra field: " << e.what());
OXEN_LOG(info, __func__ << ": failed to deserialize extra field: " << e.what() << "; extra = " << oxenc::to_hex(tx_extra.begin(), tx_extra.end()));
OXEN_LOG(err, "Failed to serialize rct signatures (prunable): " << e.what());
OXEN_LOG(err, "Failed to serialize rct signatures base: " << e.what());
OXEN_LOG(err, "Failed to parse block from blob: " << e.what());
OXEN_LOG(error, "Device disconnect exception: " << e.what());
OXEN_LOG(warn, "Invalid (non-base64) extra message `" << extra_vec[i] << "'");
OXEN_LOG(error, "Failed to load data from " << filename);
OXEN_LOG(info, "Loaded " << m_extra_messages.size() << " extra messages, current index " << m_config.current_extra_message_index);
OXEN_LOG(err, "Target account address " << command_line::get_arg(vm, arg_start_mining) << " has wrong format, starting daemon canceled");
OXEN_LOG(info, "Mining has started with " << threads_count << " threads, good luck!" );
bool Blockchain::is_within_compiled_block_hash_area(uint64_t height) const
{
#if defined(PER_BLOCK_CHECKPOINT)
  return height < m_blocks_hash_of_hashes.size() * HASH_OF_HASHES_STEP;
#else
  return false;
#endif
}

bool Blockchain::for_all_key_images(std::function<bool(const crypto::key_image&)> f) const
{
  return m_db->for_all_key_images(f);
}

bool Blockchain::for_blocks_range(const uint64_t& h1, const uint64_t& h2, std::function<bool(uint64_t, const crypto::hash&, const block&)> f) const
{
  return m_db->for_blocks_range(h1, h2, f);
}

bool Blockchain::for_all_transactions(std::function<bool(const crypto::hash&, const cryptonote::transaction&)> f, bool pruned) const
{
  return m_db->for_all_transactions(f, pruned);
}

bool Blockchain::for_all_outputs(std::function<bool(uint64_t amount, const crypto::hash &tx_hash, uint64_t height, size_t tx_idx)> f) const
{
  return m_db->for_all_outputs(f);
}

bool Blockchain::for_all_outputs(uint64_t amount, std::function<bool(uint64_t height)> f) const
{
  return m_db->for_all_outputs(amount, f);
}

void Blockchain::invalidate_block_template_cache()
{
  OXEN_LOG(debug, "Invalidating block template cache");
  m_btc_valid = false;
}

void Blockchain::cache_block_template(const block &b, const cryptonote::account_public_address &address, const std::string &nonce, const difficulty_type &diff, uint64_t height, uint64_t expected_reward, uint64_t pool_cookie)
{
  OXEN_LOG(debug, "Setting block template cache");
  m_btc = b;
  m_btc_address = address;
  m_btc_nonce = nonce;
  m_btc_height = height;
  m_btc_expected_reward = expected_reward;
  m_btc_pool_cookie = pool_cookie;
  m_btc_valid = true;
}
OXEN_LOG(info, "Mining has been stopped, " << m_threads.size() << " finished" );
OXEN_LOG(debug, "miner::pause: " << m_pausers_count << " -> " << (m_pausers_count + 1));
OXEN_LOG(debug, "miner::resume: " << m_pausers_count << " -> " << (m_pausers_count - 1));
OXEN_LOG(info, "Service Node storage server is not reachable for node: " << pubkey);
OXEN_LOG(info, "Service Node lokinet is not reachable for node: " << pubkey);
OXEN_LOG(info, "Service Node: " << pubkey << ", failed checkpoint obligation check");
OXEN_LOG(info, "Service Node: " << pubkey << ", failed pulse obligation check");
OXEN_LOG(info, "Service Node: " << pubkey << ", failed timestamp obligation check");
OXEN_LOG(info, "Service Node: " << pubkey << ", failed timesync obligation check");
OXEN_LOG(err, "The blockchain was detached to height: " << height << ", but quorum cop has already processed votes for obligations up to " << m_obligations_height);
OXEN_LOG(err, "This implies a reorg occured that was over " << REORG_SAFETY_BUFFER_BLOCKS << ". This should rarely happen! Please report this to the devs.");
OXEN_LOG(err, "The blockchain was detached to height: " << height << ", but quorum cop has already processed votes for checkpointing up to " << m_last_checkpointed_height);
OXEN_LOG(err, "This implies a reorg occured that was over " << REORG_SAFETY_BUFFER_BLOCKS << ". This should rarely happen! Please report this to the devs.");
OXEN_LOG(err, "Unhandled quorum type with value: " << (int)type);
OXEN_LOG(err, "Obligations quorum for height: " << m_obligations_height << " was not cached in daemon!");
OXEN_LOG(debug, "Decommissioned service node " << quorum->workers[node_index] << " is now passing required checks; voting to recommission");
OXEN_LOG(debug, "Service node " << quorum->workers[node_index] << " was observed with multiple IPs recently; voting to reset reward position");
OXEN_LOG(debug, "Decommissioned service node " << quorum->workers[node_index] << " has no remaining credit; voting to deregister");
OXEN_LOG(err, "Failed to add state change vote; reason: " << print_vote_verification_context(vvc, &vote));
OXEN_LOG(debug, good << " of " << total << " service nodes are active and passing checks; no state change votes required");
OXEN_LOG(err, "Checkpoint quorum for height: " << m_last_checkpointed_height << " was not cached in daemon!");
OXEN_LOG(err, "Failed to add checkpoint vote; reason: " << print_vote_verification_context(vvc, &vote));
OXEN_LOG(debug, "Don't have enough votes yet to submit a state change transaction: have " << votes.size() << " of " << STATE_CHANGE_MIN_VOTES_TO_CHANGE_STATE << " required");
OXEN_LOG(info, "A full state change tx for height: " << vote.block_height <<
OXEN_LOG(debug, "Don't have enough votes yet to submit a checkpoint: have " << votes.size() << " of " << CHECKPOINT_MIN_VOTES << " required");
OXEN_LOG(info, "Unhandled vote type with value: " << (int)vote.type);
OXEN_LOG(warn,"Full history storage requested, but " << m_transient.old_quorum_states.size() << " old quorum states found");
OXEN_LOG(error,"Quorum indexing out of bounds: " << quorum_index << ", quorum_size: " << array->size());
OXEN_LOG(info,"Quorum for height: " << height << ", was not stored by the daemon");
OXEN_LOG(warn,__func__ << ": Unsupported rct type: " << (int)tx.rct_signatures.type);
OXEN_LOG(warn,"Failed to decode input " << i);
OXEN_LOG(info,"TX: There was a service node contributor but no secret key in the tx extra for tx: " << txid);
OXEN_LOG(info,"TX: Failed to generate key derivation on height: " << block_height << " for tx: " << cryptonote::get_transaction_hash(tx));
OXEN_LOG(info,"TX: Didn't have key image proofs in the tx_extra, rejected on height: " << block_height << " for tx: " << cryptonote::get_transaction_hash(tx));
OXEN_LOG(info,"TX: Could not derive TX ephemeral key on height: " << block_height << " for tx: " << get_transaction_hash(tx) << " for output: " << output_index);
OXEN_LOG(info,"TX: Derived TX ephemeral key did not match tx stored key on height: " << block_height << " for tx: " << cryptonote::get_transaction_hash(tx) << " for output: " << output_index);
OXEN_LOG(error,"Transaction: " << cryptonote::get_transaction_hash(tx) << ", did not have valid state change data in tx extra rejecting malformed tx");
OXEN_LOG(error,"Transaction: " << cryptonote::get_transaction_hash(tx) << " in block "
OXEN_LOG(error,"Could not get a quorum that could completely validate the votes from state change in tx: " << get_transaction_hash(tx) << ", skipping transaction");
OXEN_LOG(error,"Retrieving the public key from state change in tx: " << cryptonote::get_transaction_hash(tx) << " failed");
OXEN_LOG(debug,"Received state change tx for non-registered service node " << key << " (perhaps a delayed tx?)");
OXEN_LOG(info,"Deregistration for service node: " << key);
OXEN_LOG(debug,"Received decommission tx for already-decommissioned service node " << key << "; ignoring");
OXEN_LOG(info,"Temporary decommission for service node: " << key);
OXEN_LOG(debug,"Received recommission tx for already-active service node " << key << "; ignoring");
OXEN_LOG(info,"Recommission for service node: " << key);
OXEN_LOG(debug,"Received reset position tx for service node " << key << " but it is already decommissioned; ignoring");
OXEN_LOG(info,"Reward position reset for service node: " << key);
OXEN_LOG(error,"BUG: Service node state change tx has unknown state " << static_cast<uint16_t>(state_change.state));
OXEN_LOG(info,"Invalid registration (" << cryptonote::get_transaction_hash(tx) << " @ " << block_height << "): " << e.what());
OXEN_LOG(info,"Register TX: Had service node registration fields, but could not decode contribution on height: " << block_height << " for tx: " << cryptonote::get_transaction_hash(tx));
OXEN_LOG(info,"Register TX: Contribution transferred: " << stake.transferred << " didn't meet the minimum transfer requirement: " << min_transfer << " on height: " << block_height << " for tx: " << cryptonote::get_transaction_hash(tx));
OXEN_LOG(info,"Register TX: Number of participants: " << total_num_of_addr <<
OXEN_LOG(info,"Invalid registration: duplicate reserved address in registration (tx " << cryptonote::get_transaction_hash(tx) << ")");
OXEN_LOG(info,"New service node registered: "     << key << " on height: " << block_height);
OXEN_LOG(info,"New service node registered: " << key << " at block height: " << block_height);
OXEN_LOG(info,"TX: Could not decode contribution for service node: " << stake.service_node_pubkey << " on height: " << block_height << " for tx: " << cryptonote::get_transaction_hash(tx));
OXEN_LOG(info,"TX: Service node: " << stake.service_node_pubkey
OXEN_LOG(info,"TX: Failed to get tx secret key from contribution received on height: "  << block_height << " for tx: " << cryptonote::get_transaction_hash(tx));
OXEN_LOG(info,"TX: Amount " << stake.transferred << " did not meet min " << min_contribution
OXEN_LOG(info,"TX: Amount " << stake.transferred << " is too large (max " << max << ").  This is probably a result of competing stakes.");
OXEN_LOG(info,"Contribution of " << stake.transferred << " received for service node " << stake.service_node_pubkey);
OXEN_LOG(info,"Verifying alt-block " << height << ":" << hash << " against main chain quorum");
OXEN_LOG(info,"Verifying alt-block " << height << ":" << hash << " against alt chain quorum(s)");
OXEN_LOG(info,"Alt-block " << height << ":" << hash << " verified successfully");
OXEN_LOG(info,"Block " << hash << " not found in main DB, searching alt DB");
OXEN_LOG(error,"Failed to find block " << hash);
OXEN_LOG(error,"Failed to parse alt block blob at " << alt_data.height << ":" << hash);
OXEN_LOG(error,"Insufficient blocks to get quorum entropy for Pulse, height is " << top_height << ", we need " << PULSE_QUORUM_ENTROPY_LAG << " blocks.");
OXEN_LOG(error,"Failed to get quorum entropy for Pulse, block at " << prev_height << prev_hash);
OXEN_LOG(error,"Failed to get quorum entropy for Pulse, next block parent " << top_hash);
OXEN_LOG(debug,"Insufficient active Service Nodes for Pulse: " << active_snode_list.size());
default: OXEN_LOG(error,"Unhandled quorum type enum with value: " << type_int); continue;
else                                   OXEN_LOG(info,"Service node expired: " << pubkey << " at block height: " << block_height);
OXEN_LOG(err,"Failed to get historical block to find expired nodes in v9: " << e.what());
OXEN_LOG(info,"Unexpected state_t's hash: " << starting_state->block_hash
OXEN_LOG(err,"Failed to store service node info: failed to serialize long term data: " << e.what());
OXEN_LOG(err,"Failed to store service node info: failed to serialize short term data: " << e.what());
OXEN_LOG(warn,"Failed to derive x25519 pubkey from ed25519 pubkey " << proof->pubkey_ed25519);
REJECT_PROOF(log) do { OXEN_LOG(debug,"Rejecting uptime proof from " << proof.pubkey << ": " log); return false; } while (0)
OXEN_LOG(debug,"Accepted uptime proof from " << proof.pubkey);
REJECT_PROOF(log) do { OXEN_LOG(debug,"Rejecting uptime proof from " << proof->pubkey << ": " log); return false; } while (0)
OXEN_LOG(debug,"Accepted uptime proof from " << proof->pubkey);
OXEN_LOG(debug,"no connection available: could not find primary pubkey from x25519 pubkey " << x25519_pub);
OXEN_LOG(debug,"no connection available: primary pubkey " << pubkey << " is not registered");
OXEN_LOG(debug,"no connection available: service node " << pubkey << " has no associated ip and/or port");
OXEN_LOG(debug,"Dropping " << type << " reachable report: " << pubkey << " is not a registered SN pubkey");
OXEN_LOG(debug,"Received " << type << (reachable ? " reachable" : " UNREACHABLE") << " report for SN " << pubkey);
OXEN_LOG(warn,"Last serialised quorum height: " << data_in.states.back().height
OXEN_LOG(err,"Failed to parse service node data from blob: " << e.what());
OXEN_LOG(error,tr("Could not parse registration arguments: ") << e.what());
OXEN_LOG(debug,"SN vote at height " << height << " invalid: not fully funded");
OXEN_LOG(debug,"SN vote at height " << height << " invalid: height <= reg height (" << registration_height << ")");
OXEN_LOG(debug,"SN vote at height " << height << " invalid: height <= last decomm height (" << last_decommission_height << ")");
OXEN_LOG(debug,"SN vote at height " << height << " invalid: height <= active-since height (" << active_since_height << ")");
OXEN_LOG(trace,"SN vote at height " << height << " is valid.");
OXEN_LOG(debug,"SN state transition invalid: " << height << " is not a valid vote height");
OXEN_LOG(debug,"SN deregister invalid: vote height (" << height << ") <= registration_height (" << registration_height << ")");
OXEN_LOG(debug,"SN ip change penality invalid: vote height (" << height << ") <= last_ip_change_height (" << last_ip_change_height << ")");
OXEN_LOG(debug,"SN deregister invalid: vote height (" << height << ") < registration_height (" << registration_height << ")");
OXEN_LOG(debug, log_prefix(context) << "Stage timed out: insufficient responses. Expected "
OXEN_LOG(error, log_prefix(context) << "Internal error: expected bitset " << bitset_view16(validator_bitset) << ", but accepted and received " << bitset_view16(stage.bitset));
OXEN_LOG(trace, log_prefix(context) << "Received valid message from the past (round " << +msg.round  << "), ignoring");
OXEN_LOG(trace, log_prefix(context) << "Received invalid message type, dropped");
OXEN_LOG(trace, log_prefix(context) << "Message received early " << msg_source_string(context, msg) << ", queueing until we're ready.");
OXEN_LOG(trace, log_prefix(context) << "Dropping " << msg_source_string(context, msg) << ". Not a locked in participant, bitset is " << bitset_view);
OXEN_LOG(trace, log_prefix(context) << "Dropping " << msg_source_string(context, msg) << ". Message quorum position indexes oob");
OXEN_LOG(trace, log_prefix(context) << "Received handshake with quorum position bit (" << msg.quorum_position << ") "
OXEN_LOG(trace, log_prefix(context) << "Received unparsable pulse block template blob");
OXEN_LOG(trace, log_prefix(context) << "Received pulse block template specifying different round " << +block.pulse.round
OXEN_LOG(trace, log_prefix(context) << "Received pulse block template specifying different validator handshake bitsets " << block_bitset << ", expected " << our_bitset);
OXEN_LOG(trace, log_prefix(context) << "Dropping " << msg_source_string(context, msg)
OXEN_LOG(trace, log_prefix(context) << "Dropping " << msg_source_string(context, msg)
OXEN_LOG(debug, log_prefix(context) << "Network is currently producing block " << chain_height << ", waiting until next block");
OXEN_LOG(debug, log_prefix(context) << "Failed to query the block hash for height " << chain_height - 1);
OXEN_LOG(debug, log_prefix(context) << "Failed to query the block hash for height " << chain_height - 1);
OXEN_LOG(error, log_prefix(context) << "Failed to query the block data for Pulse timings");
OXEN_LOG(info, log_prefix(context) << "Pulse has timed out, reverting to accepting miner blocks only.");
OXEN_LOG(info, log_prefix(context) << "Insufficient Service Nodes to execute Pulse on height " << context.wait_for_next_block.height << ", we require a PoW miner block. Sleeping until next block.");
OXEN_LOG(debug, log_prefix(context) << "Generate Pulse quorum: " << context.prepare_for_round.quorum);
OXEN_LOG(debug, log_prefix(context) << "Block height changed whilst waiting for round " << +context.prepare_for_round.round << ", restarting Pulse stages");
OXEN_LOG(info, log_prefix(context) << "Waiting for round " << +context.prepare_for_round.round << " to start in " << tools::friendly_duration(start_time - now));
OXEN_LOG(debug, log_prefix(context) << "FAULTY NODE ACTIVATED");
OXEN_LOG(debug, log_prefix(context) << "SLEEP TIME ACTIVATED " << tools::to_seconds(sleep_time) << "s");
OXEN_LOG(info, log_prefix(context) << "We are a pulse validator, sending handshake bit and collecting other handshakes.");
OXEN_LOG(info, log_prefix(context) << "We are the block producer for height " << context.wait_for_next_block.height << " in round " << +context.prepare_for_round.round << ", awaiting handshake bitsets.");
OXEN_LOG(debug, log_prefix(context) << "Non-participant for round, waiting on next round or block.");
OXEN_LOG(error, log_prefix(context) << "Attempting to invoke and send a Pulse participation handshake unexpectedly failed. " << e.what());
OXEN_LOG(info, log_prefix(context) << "Collected validator handshakes " << bitset_view16(stage.bitset) << (missing_handshakes ? ", we timed out and some handshakes were not seen! " : ". ") << "Sending handshake bitset and collecting other validator bitsets.");
OXEN_LOG(error, log_prefix(context) << "Attempting to invoke and send a Pulse validator bitset unexpectedly failed. " << e.what());
OXEN_LOG(trace, log_prefix(context) << "Collected from V[" << quorum_index << "], handshake bitset " << bitset_view16(*bitset));
OXEN_LOG(debug, log_prefix(context) << count << "/" << quorum.size()
OXEN_LOG(debug, log_prefix(context) << "The participating validator bitset " << bitset_view16(best_bitset)
OXEN_LOG(debug, log_prefix(context) << "We heard back from less than " << service_nodes::PULSE_BLOCK_REQUIRED_SIGNATURES << " of the validators ("
OXEN_LOG(info, log_prefix(context) << count << "/" << quorum.size()
OXEN_LOG(warn, log_prefix(context) << "Block producer (us) is not available on the service node list, waiting until next round");
OXEN_LOG(warn, log_prefix(context) << "Block producer (us) is not an active service node, waiting until next round");
OXEN_LOG(error, log_prefix(context) << "Failed to generate a block template, waiting until next round");
OXEN_LOG(debug, log_prefix(context) << "Block height changed whilst preparing block template for round " << +context.prepare_for_round.round << ", restarting Pulse stages");
OXEN_LOG(info, log_prefix(context) << "Validators are handshaken and ready, sending block template from producer (us) to validators.\n" << cryptonote::obj_to_json_str(block));
OXEN_LOG(info, log_prefix(context) << "Valid block received: " << cryptonote::obj_to_json_str(context.transient.wait_for_block_template.block));
OXEN_LOG(info, log_prefix(context) << "Timed out, block template was not received");
OXEN_LOG(info, log_prefix(context) << "Received " << bitset_view16(stage.bitset).count() << " random value hashes from " << bitset_view16(stage.bitset) << (timed_out ? ". We timed out and some hashes are missing" : ""));
OXEN_LOG(debug, log_prefix(context) << "Final random value seeding with V[" << index << "] " << string.view());
OXEN_LOG(info, log_prefix(context) << "Block final random value " << oxenc::to_hex(tools::view_guts(final_block.pulse.random_value.data)) << " generated from validators " << bitset_view16(stage.bitset));
OXEN_LOG(debug, log_prefix(context) << "Signature added: " << validator_index << ":" << context.prepare_for_round.quorum.validators[validator_index] << ", " << *signature);
OXEN_LOG(debug, log_prefix(context) << "Final signed block constructed\n" << cryptonote::obj_to_json_str(final_block));
OXEN_LOG(debug, "Pulse: Network at block " << height << " is not ready for Pulse until block " << *hf16 << ", waiting");
OXEN_LOG(error, "Could not get service node state change from tx: " << get_transaction_hash(tx) << ", possibly corrupt tx in your blockchain, rejecting malformed state change");
OXEN_LOG(info, "Could not get service node state change from tx: " << get_transaction_hash(pool_tx) << ", possibly corrupt tx in the pool");
OXEN_LOG(error, "Could not get key image unlock from tx: " << get_transaction_hash(tx) << ", tx to add is possibly invalid, rejecting");
OXEN_LOG(info, "Could not get key image unlock from tx: " << get_transaction_hash(tx) << ", possibly corrupt tx in the pool");
OXEN_LOG(info, "New TX: " << get_transaction_hash(tx) << ", has TX: " << get_transaction_hash(pool_tx) << " from the pool that is requesting to unlock the same key image already.");
OXEN_LOG(error, "Could not get acquire name service from tx: " << get_transaction_hash(tx) << ", tx to add is possibly invalid, rejecting");
OXEN_LOG(info, "Could not get acquire name service from tx: " << get_transaction_hash(tx) << ", possibly corrupt tx in the pool");
OXEN_LOG(info, "New TX: " << get_transaction_hash(tx) << ", has TX: " << get_transaction_hash(pool_tx) << " from the pool that is requesting the same ONS entry already.");
OXEN_LOG(error, "Unrecognised transaction type: " << tx.type << " for tx: " << get_transaction_hash(tx));
OXEN_LOG(info, "transaction is too heavy: " << tx_weight << " bytes, maximum weight: " << tx_weight_limit);
OXEN_LOG(warn, "Not re-adding popped/incoming tx " << id << " to the mempool: it conflicts with blink tx " << tx_hash);
OXEN_LOG(debug, "Incoming blink tx is approved, but has " << conflict_txs.size() << " conflicting local tx(es); dropping conflicts");
OXEN_LOG(info, "Transaction with id= "<< id << " used already spent key images");
OXEN_LOG(info, "Transaction with id= "<< id << " already has a duplicate tx for height");
OXEN_LOG(info, "Transaction with id= "<< id << " has at least one invalid output");
OXEN_LOG(error, "Error adding transaction to txpool: " << e.what());
OXEN_LOG(error, "internal error: error adding transaction to txpool: " << e.what());
OXEN_LOG(info, "Transaction added to pool: txid " << id << " weight: " << tx_weight << " fee/byte: " << (fee / (double)(tx_weight ? tx_weight : 1)));
OXEN_LOG(error, "Blink error: incoming blink tx " << id << " conflicts with another blink tx " << tx_hash);
OXEN_LOG(debug, "Conflicting tx " << conflict_txs[i] << (heights[i] ? "mined at height " + std::to_string(heights[i]) : "in mempool"));
OXEN_LOG(warn, "Removing conflicting tx " << tx << " from mempool for incoming blink tx " << id);
OXEN_LOG(error, "Internal error: Unable to clear conflicting tx " << tx << " from mempool for incoming blink tx " << id);
OXEN_LOG(info, "Incoming blink tx requires a rollback to the " << rollback_height_needed << " to un-mine conflicting transactions");
OXEN_LOG(info, "Removing tx " << txid << " from txpool: weight: " << meta->weight << ", fee/byte: " << tx_fee);
OXEN_LOG(error, "Error while pruning txpool: " << e.what());
OXEN_LOG(info, "Pool weight after pruning is still larger than limit: " << m_txpool_weight << "/" << m_txpool_max_weight);
OXEN_LOG(error, "Failed to remove tx from txpool: " << e.what());
OXEN_LOG(info, "Tx " << txid << " removed from tx pool due to outdated, age: " << tx_age );
OXEN_LOG(info, "Removing tx " << txid << " from tx pool, but it was not found in the sorted txs container!");
OXEN_LOG(warn, "Failed to remove stuck transaction: " << txid);
OXEN_LOG(info, "TX in pool could not be parsed from blob, txid: " << txid);
OXEN_LOG(info, "TX type: " << tx.type << " considered for relaying failed tx inputs check, txid: " << txid << ", reason: " << print_tx_verification_context(tvc, &tx));
OXEN_LOG(error, "Failed to upate txpool transaction metadata: " << e.what());
OXEN_LOG(error, "Failed to update txpool transaction metadata: " << e.what());
OXEN_LOG(error, "Failed to get tx meta from txpool: " << e.what());
OXEN_LOG(debug, "Found " << key_image_conflicts.size() << " conflicting key images for blink tx " << txid << "; checking to see if we can roll back");
OXEN_LOG(error, "Unable to get transactions for block " << block.hash);
OXEN_LOG(debug, "Blink admission requires rolling back to height " << earliest);
OXEN_LOG(warn, "Blink admission of " << txid << " is not possible even with a rollback: found " << key_image_conflicts.size() << " key image conflicts in immutable blocks");
OXEN_LOG(debug, "Marking " << txid << " as double spending " << itk.k_image);
OXEN_LOG(error, "Failed to update tx meta: " << e.what());
OXEN_LOG(debug, "Filling block template, median weight " << median_weight << ", " << m_txs_by_fee_and_receive_time.size() << " txes in the pool");
OXEN_LOG(debug, "Considering " << sorted_it.second << ", weight " << meta.weight << ", current block weight " << total_weight << "/" << max_total_weight << ", current reward " << print_money(best_reward));
OXEN_LOG(debug, "  would decrease reward to " << print_money(next_reward));
OXEN_LOG(error, "Failed to check transaction readiness: " << e.what());
OXEN_LOG(error, "Failed to update tx meta: " << e.what());
OXEN_LOG(debug, "  added, new block weight " << total_weight << "/" << max_total_weight << ", reward " << print_money(best_reward));
OXEN_LOG(debug, "Block template filled with " << bl.tx_hashes.size() << " txes, weight "
OXEN_LOG(info, "Transaction " << txid << " is too big (" << meta.weight << " bytes), removing it from pool");
OXEN_LOG(info, "Transaction " << txid << " is in the blockchain, removing it from pool");
OXEN_LOG(info, "Removing tx " << txid << " from tx pool, but it was not found in the sorted txs container!");
OXEN_LOG(warn, "Failed to remove corrupt transaction: " << txid);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(debug, "Additional outputs needed: " << absolute_offsets.size() - outputs.size());
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(error, "Unable to get transactions for block for updating ONS DB: " << cryptonote::get_block_hash(blk));
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(info, "Blockchain initialized. last block: " << m_db->height() - 1 << ", " << epee::misc_utils::get_time_interval_string(timestamp_diff) << " time ago");
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(info, "Blockchain stored OK, took: " << save << " ms");
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(err, "Error when popping blocks after processing " << i << " blocks: " << e.what());
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(err, "Error popping block from blockchain: " << e.what());
OXEN_LOG(warn, pruned << " pruned txes could not be added back to the txpool");
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(error, "Found block " << h << " in alt chain, but failed to parse it");
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(info, "Rollback to height " << rollback_height << " was successful.");
OXEN_LOG(debug, "Rolling back to height " << rollback_height);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(error, "The block was inserted as invalid while connecting new alternative chain, block_id: " << blkid);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(warn, "The miner transaction in block has invalid height: " << var::get<txin_gen>(b.miner_tx.vin[0]).height << ", expected: " << height);
OXEN_LOG(debug, "Miner tx hash: " << get_transaction_hash(b.miner_tx));
OXEN_LOG(error, "miner transaction has money overflow in block " << get_block_hash(b));
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(error, "Governance reward amount incorrect.  Should be: " << print_money(reward_parts.governance_paid) << ", is: " << print_money(b.miner_tx.vout.back().amount));
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "requesting " << count << " from " << start_height << ", cached");
OXEN_LOG(trace, "requesting " << count << " from " << start_height << ", incremental");
OXEN_LOG(trace, "requesting " << count << " from " << start_height << ", uncached");
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(debug, "Not using cached template: address " << (bool)(info.miner_address != m_btc_address) << ", nonce " << (m_btc_nonce == ex_nonce) << ", cookie " << (m_btc_pool_cookie == m_tx_pool.cookie()) << ", from_block " << (!!from_block));
OXEN_LOG(debug, "Miner tx creation has no luck with delta_extra size = " << delta << " and " << delta - 1);
OXEN_LOG(debug, "Setting extra for block: " << b.miner_tx.extra.size() << ", try_count=" << try_count);
OXEN_LOG(err, "Failed to create_block_template with " << 10 << " tries");
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(info, "main blockchain wrong height: " << m_db->height() << ", alt_chain: " << alt_chain.front().height);
OXEN_LOG(info, "alternate chain does not appear to connect to main chain...: " << alt_chain.front().bl.prev_id);
OXEN_LOG(info, "alternative chain has wrong connection to main chain: " << h << ", mismatched with: " << alt_chain.front().bl.prev_id);
OXEN_LOG(debug, "alternative chain is too old to consider: " << h);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(error, "Unexpected failure to query blocks for alt chain switching calculation from " << start << " to " << (end - 1));
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(err, "Invalid block at height " << start_offset + i << ". " << e.what());
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(error, "Get block checkpoint from DB failed non-trivially at height: " << block_height << ", what = " << e.what());
OXEN_LOG(err, "Error retrieving blocks, missed " << missed_tx_ids.size()
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(error, "Unexpected output data size: expected " << req.outputs.size() << ", got " << data.size());
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(warn, "Non-critical error trying to find block by hash in BlockchainDB, hash: " << *bl_it);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(err, "Invalid block: " << block_hash);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(error, "Prunable data hash not found for " << tx_hash);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(info, "BLOCK ADDED AS INVALID: " << (*i_res.first) << std::endl << ", prev_id=" << block.prev_id << ", m_invalid_blocks count=" << m_invalid_blocks.size());
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(debug, "block " << id << " found in main chain");
OXEN_LOG(debug, "block " << id << " found in alternative chains");
OXEN_LOG(debug, "block " << id << " found in m_invalid_blocks");
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(info, "HASH: " << "-" << " I/M/O: " << tx.vin.size() << "/" << ring_size << "/" << tx.vout.size() << " H: " << 0 << " chcktx: " << a);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(info, "HASH: " <<  get_transaction_hash(tx) << " I/M/O: " << tx.vin.size() << "/" << ring_size << "/" << tx.vout.size() <<
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(error, "Could not verify key image unlock transaction signature for tx: " << get_transaction_hash(tx));
OXEN_LOG(debug, "lo " << print_money(lo) << ", qlo " << print_money(qlo) << ", mask " << mask);
OXEN_LOG(debug, "Using " << print_money(fees.first) << "/byte + " << print_money(fees.second) << "/out fee");
OXEN_LOG(debug, "Using " << print_money(fees.first) << "/kB fee");
OXEN_LOG(error, "Failed to determine block reward, using placeholder " << print_money(BLOCK_REWARD_OVERESTIMATE) << " as a high bound");
OXEN_LOG(debug, "Estimating " << grace_blocks << "-block fee at " << print_money(fee.first) << "/" << (per_byte ? "byte" : "kB") <<
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(error, "Failed to return taken transaction with hash: " << get_transaction_hash(tx.first) << " to tx_pool");
OXEN_LOG(info, "Removing txid " << txid << " from the pool");
OXEN_LOG(error, "Failed to remove txid " << txid << " from the pool");
OXEN_LOG(info, "Block with id: " << blk_hash << ", has invalid version " << static_cast<int>(blk.major_version) << "." << +blk.minor_version <<
OXEN_LOG(trace, "Blockchain::" << __func__);
//     OXEN_LOG(warn, "Double spend detected in transaction (id: " << tx_id);
OXEN_LOG(info, "Height: " << new_height << " coinbase weight: " << coinbase_weight << " cumm: "
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(trace, "block with id = " << id << " already exists");
OXEN_LOG(error, "Get block checkpoint from DB failed at height: " << block_height << ", what = " << e.what());
OXEN_LOG(info, "Adding checkpoints from blockchain hashfile: " << file_path);
OXEN_LOG(info, "Hard-coded max checkpoint height is " << prev_max_height);
OXEN_LOG(info, "ignoring checkpoint height " << height);
OXEN_LOG(info, "Adding checkpoint height " << height << ", hash=" << blockhash);
OXEN_LOG(info, "Failed to add checkpoint at height " << height << ", hash=" << blockhash);
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(error, "Exception in cleanup_handle_incoming_blocks: " << e.what());
OXEN_LOG(info, "Dumping block hashes, we're now 4k past " << m_blocks_hash_check.size());
OXEN_LOG(debug, "Blocks " << height << " - " << (height + hashes.size() - 1) << " start at " << first_index << " and end at " << last_index);
OXEN_LOG(debug, "invalid hash for blocks " << n * HASH_OF_HASHES_STEP << " - " << (n * HASH_OF_HASHES_STEP + HASH_OF_HASHES_STEP - 1));
OXEN_LOG(debug, "usable: " << usable << " / " << hashes.size());
OXEN_LOG(trace, "Blockchain::" << __func__);
OXEN_LOG(debug, "block_batches: " << batches);
OXEN_LOG(debug, "Prepare blocks took: " << prepare << " ms");
OXEN_LOG(debug, "Prepare scantable took: " << scantable << " ms");
OXEN_LOG(info, "Loading precomputed blocks (" << checkpoints.size() << " bytes)");
OXEN_LOG(info, "Precomputed blocks hash: " << hash << ", expected " << EXPECTED_SHA256_HASH);
OXEN_LOG(error, "Failed to load hashes - unexpected data size " << checkpoints.size() << ", expected " << size_needed);
OXEN_LOG(info, nblocks << " block hashes loaded");
OXEN_LOG(info, "Registration tx rejected: too many contributors (" << portions.size() << " > " << oxen::MAX_CONTRIBUTORS_V1 << ")");
OXEN_LOG(info, "Registration tx rejected: portion " << i << " too small (" << portions[i].second << " < " << min_portions << ")");
OXEN_LOG(info, "Registration tx rejected: portion " << i << " exceeds available portions");
OXEN_LOG(info, "Registration tx rejected: too many contributors (" << stakes.size() << " > " << oxen::MAX_CONTRIBUTORS_HF19 << ")");
OXEN_LOG(info, "Registration tx rejected: stake " << i << " too small (" << stakes[i].second << " < " << min_stake << ")");
OXEN_LOG(info, "Registration tx rejected: stake " << i << " (" << stakes[i].second << ") exceeds available remaining stake (" << remaining << ")");
OXEN_LOG(info, "Unhandled vote type with value: " << (int)vote.type);
OXEN_LOG(info, "Quorum worker index in was out of bounds: " << worker_index << ", expected to be in range of: [0, " << quorum.workers.size() << ")");
OXEN_LOG(info, "Validator's index was out of bounds: " << validator_index << ", expected to be in range of: [0, " << quorum.validators.size() << ")");
OXEN_LOG(info, "Unknown state change to new state: " << static_cast<uint16_t>(state_change.state));
OXEN_LOG(info, "Received state change tx for height: " << state_change.block_height
OXEN_LOG(info, "Voter quorum index is duplicated: " << vote.validator_index);
OXEN_LOG(info, "Invalid signature for voter " << vote.validator_index << "/" << key);
OXEN_LOG(info, "Checkpoint given but not expecting a checkpoint at height: " << checkpoint.height);
OXEN_LOG(info, "Checkpoint failed signature validation at block " << checkpoint.height << " " << checkpoint.block_hash);
OXEN_LOG(info, "Non service-node checkpoints should have no signatures, checkpoint failed at height: " << checkpoint.height);
OXEN_LOG(info, "Received vote for height: " << vote.block_height << ", is older than: " << VOTE_LIFETIME
OXEN_LOG(info, "Received vote for height: " << vote.block_height << ", is newer than: " << latest_height
OXEN_LOG(info, "Unhandled vote type with value: " << (int)vote.type);
OXEN_LOG(debug, "Signature accepted for " << vote.type << " voter " << vote.index_in_group << "/" << key
OXEN_LOG(info, "Unhandled find_vote type with value: " << (int)find_vote.type);
OXEN_LOG(warn, "deserialization failed: " <<  e.what());
OXEN_LOG(error, "Developer error: Unhandled quorum enum with value: " << (size_t)type);
OXEN_LOG(debug, "Calculated excess: " << excess);
OXEN_LOG(debug, "Calculated threshold: " << threshold);
OXEN_LOG(debug, "Created new swarm from excess: " << new_swarm_id);
OXEN_LOG(trace, "calc_swarm_changes. swarms: " << swarm_to_snodes.size() << ", regs: " << unassigned_snodes.size());
OXEN_LOG(debug, "Created initial swarm " << new_swarm_id);
OXEN_LOG(debug, entry.first << ": " << entry.second.size());
OXEN_LOG(debug, "Stolen 1 snode from " << excess_snode.public_key << " and donated to " << swarm.swarm_id);
OXEN_LOG(warn, "swarm " << it->first << " is DECOMMISSIONED");
OXEN_LOG(debug, entry.first << ": " << entry.second.size());
OXEN_LOG(debug, "n_indices is only " << n_indices << ", not checking");
OXEN_LOG(error, "amount of unique indices is too low (amount of rct indices is " << rct_indices.size() << ", out of total " << n_indices << "indices.");
OXEN_LOG(error, "median offset index is too low (median is " << median << " out of total " << rct_outs_available << "offsets). Transactions should contain a higher fraction of recent outputs.");
OXEN_LOG(warn, "Unexpected blob size=" << blob.data.size() << ", in ONS DB does not match expected size=" << dest_size);
OXEN_LOG(error, "Unexpected encrypted value blob with size=" << value.size() << ", in ONS db larger than the available size=" << result.encrypted_value.buffer.size());
default: OXEN_LOG(error, "Unhandled ons type enum with value: " << (int)type << ", in: " << __func__); break;
OXEN_LOG(info, "Failed to execute statement: " << sqlite3_sql(statement.statement) <<", reason: " << sqlite3_errstr(step_result));
OXEN_LOG(error, "Can not compile SQL statement:\n" << query << "\nReason: " << sqlite3_errstr(prepare_result));
OXEN_LOG(error, "Failed to initialize sqlite3: " << sqlite3_errstr(sql_init));
OXEN_LOG(error, "Failed to open ONS db at: " << file_path << ", reason: " << sqlite3_errstr(sql_open));
OXEN_LOG(error, "Failed to set journal mode to WAL: " << sqlite3_errstr(exec));
OXEN_LOG(error, "Failed to set synchronous mode to NORMAL: " << sqlite3_errstr(exec));
OXEN_LOG(error, "Unexpected value len=" << value.size() << " greater than the expected capacity=" << mapping_value::BUFFER_SIZE);
OXEN_LOG(error, "Encrypted value pre-allocated buffer too small=" << buffer.size() << ", required=" << encryption_len);
OXEN_LOG(error, "Encrypted value size is invalid=" << len << ", expected=" << expected_len);
OXEN_LOG(error, "Can not generate SQL table for ONS: " << (table_err_msg ? table_err_msg : "??"));
OXEN_LOG(error, "Can not migrate SQL mappings table for ONS: " << (table_err_msg ? table_err_msg : "??"));
OXEN_LOG(error, "Failed to begin transaction " << ", reason=" << (sql_err ? sql_err : "??"));
OXEN_LOG(error, "Failed to " << (commit ? "end " : "rollback ") << " transaction to ONS DB, reason=" << (sql_err ? sql_err : "??"));
OXEN_LOG(info, "Failed to save ONS owner to DB tx: " << tx_hash << ", type: " << entry.type << ", name_hash: " << entry.name_hash << ", owner: " << entry.owner.to_string(ons_db.network_type()));
OXEN_LOG(error, "Failed to add or get owner with key=" << entry.owner.to_string(ons_db.network_type()));
OXEN_LOG(error, "Failed to add or get backup owner with key=" << entry.backup_owner.to_string(ons_db.network_type()));
OXEN_LOG(error, "Failed to add or get owner with key=" << entry.owner.to_string(ons_db.network_type()));
OXEN_LOG(error, "Failed to add or get backup owner with key=" << entry.backup_owner.to_string(ons_db.network_type()));
OXEN_LOG(info, "Failed to save ONS entry to DB tx: " << tx_hash << ", type: " << entry.type << ", name_hash: " << entry.name_hash << ", owner: " << entry.owner.to_string(ons_db.network_type()));
OXEN_LOG(error, "Failed to compile SQL statement for updating ONS record=" << sql);
OXEN_LOG(debug, "destinations include " << num_stdaddresses << " standard addresses and " << num_subaddresses << " subaddresses");
OXEN_LOG(error, "We allocated more reward " << cryptonote::print_money(allocated) << " than what was available " << cryptonote::print_money(base_reward_unpenalized));
OXEN_LOG(error, "We allocated reward but there was still " << cryptonote::print_money(remainder) << " oxen left to distribute.");
OXEN_LOG(debug, "Encrypting payment id " << payment_id8);
OXEN_LOG(info,"Encrypted payment ID: " << payment_id8);
OXEN_LOG(err,"real_output index (" << src_entr.real_output << ")bigger than output_keys.size()=" << src_entr.outputs.size());
OXEN_LOG(err,"derived public key mismatch with output public key at index " << idx << ", real out " << src_entr.real_output << "!\nderived_key:"
OXEN_LOG(err,"amount " << src_entr.amount << ", rct " << src_entr.rct);
OXEN_LOG(err,"tx pubkey " << src_entr.real_out_tx_key << ", real_output_in_tx_index " << src_entr.real_output_in_tx_index);
OXEN_LOG(err,"Transaction inputs money ("<< summary_inputs_money << ") less than outputs money (" << summary_outs_money << ")");
OXEN_LOG(err,"invalid burn amount: tx does not have enough unspent funds available; amount_in: " << std::to_string(amount_in) << "; amount_out + tx_params.burn_fixed: " << std::to_string(amount_out) << " + " << std::to_string(tx_params.burn_fixed));
OXEN_LOG(error, "Unsupported network address type: " << (unsigned)type);
OXEN_LOG(error, "Failed to deinitialize p2p: " << e.what());
OXEN_LOG(error, "Failed to deinitialize core: " << e.what());
OXEN_LOG(error, "Failed to stop cryptonote protocol: " << e.what());
OXEN_LOG(error, "Invalid hash or height value: " << arg);
OXEN_LOG(error, "Invalid transaction hash: " << str_hash);
OXEN_LOG(error, "invalid key image hash: " << str);
OXEN_LOG(info, "Changed bootstrap daemon address to " << url);
OXEN_LOG(info, "LMQ RPC request '" << (call.is_public ? "rpc." : "admin.") << name << "' called with invalid/unparseable data: " << e.what());
OXEN_LOG(warn, "LMQ RPC request '" << (call.is_public ? "rpc." : "admin.") << name << "' failed with: " << e.what());
OXEN_LOG(warn, "LMQ RPC request '" << (call.is_public ? "rpc." : "admin.") << name << "' "
OXEN_LOG(warn, "LMQ RPC request '" << (call.is_public ? "rpc." : "admin.") << name << "' "
OXEN_LOG(trace, "Renewed mempool subscription request from conn id " << m.conn << " @ " << m.remote);
OXEN_LOG(debug, "New " << (sub_type == mempool_sub_type::blink ? "blink" : "all") << " mempool subscription request from conn " << m.conn << " @ " << m.remote);
OXEN_LOG(trace, "Renewed block subscription request from conn id " << m.conn << " @ " << m.remote);
OXEN_LOG(debug, "New block subscription request from conn " << m.conn << " @ " << m.remote);
OXEN_LOG(debug, "Removing " << conn << " from " << desc << " subscriptions: subscription timed out");
OXEN_LOG(info, "Forbidden HTTP request for restricted endpoint " << req->getMethod() << " " << req->getUrl());
OXEN_LOG(info, "Invalid HTTP request for " << req->getMethod() << " " << req->getUrl());
OXEN_LOG(info, "HTTP RPC request '" << data.uri << "' called with invalid/unparseable data: " << e.what());
OXEN_LOG(warn, "HTTP RPC request '" << data.uri << "' failed with: " << e.what());
OXEN_LOG(warn, "HTTP RPC request '" << data.uri << "' raised an exception: " << e.what());
OXEN_LOG(warn, "HTTP RPC request '" << data.uri << "' raised an unknown exception");
OXEN_LOG(info, "HTTP RPC " << data.uri << " [" << data.request.context.remote << "] OK (" << bytes << " bytes)" << call_duration);
OXEN_LOG(trace, "Deferring long poll request from " << data->request.context.remote << ": long polling requested and remote's checksum matches current pool (" << checksum << ")");
OXEN_LOG(trace, "Ignoring long poll request from " << data->request.context.remote << ": pool hash mismatch (remote: " << req.tx_pool_checksum << ", local: " << checksum << ")");
OXEN_LOG(debug, "TX pool changed; sending tx pool to " << long_pollers.size() << " pending long poll connections");
OXEN_LOG(trace, "Sending deferred long poll pool update to " << data.request.context.remote);
OXEN_LOG(trace, "Sending long poll timeout to " << it->first->request.context.remote);
OXEN_LOG(debug, "Timed out " << count << " long poll connections");
OXEN_LOG(trace, "None of " << long_pollers.size() << " established long poll connections reached timeout");
OXEN_LOG(trace, "Received " << req.getMethod() << " " << req.getUrl() << " request from " << request.context.remote);
OXEN_LOG(info, "Invalid JSON RPC request from " << data->request.context.remote << ": no 'method' in request");
OXEN_LOG(info, "Invalid JSON RPC request from " << data->request.context.remote << ": method '" << method << "' is invalid");
OXEN_LOG(warn, "Invalid JSON RPC request from " << data->request.context.remote << ": method '" << method << "' is restricted");
OXEN_LOG(debug, "Incoming JSON RPC request for " << method << " from " << data->request.context.remote);
OXEN_LOG(trace, "closing " << m_listen_socks.size() << " listening sockets");
OXEN_LOG(warn, "bootstrap daemon request failed: " << e.what());
OXEN_LOG(debug, "Submitting post request to " << url);
OXEN_LOG(debug, url << ": " <<
OXEN_LOG(debug, "on_get_blocks: " << bs.size() << " blocks, " << ntxes << " txes, size " << size);
OXEN_LOG(debug, "on_get_alt_blocks_hashes: " << blks.size() << " blocks " );
OXEN_LOG(debug, "GET_TX_GLOBAL_OUTPUTS_INDEXES: [" << res.o_indexes.size() << "]");
OXEN_LOG(debug, "Found " << txs.size() << "/" << vh.size() << " transactions on the blockchain");
OXEN_LOG(debug, "Found " << found_in_pool << "/" << vh.size() << " transactions in the pool");
OXEN_LOG(debug, res.txs.size() << " transactions found, " << res.missed_tx.size() << " not found");
OXEN_LOG(error, "Invalid hash: " << i->id_hash);
OXEN_LOG(warn, "[on_send_raw_tx]: Failed to parse tx from hexbuff: " << req.tx_as_hex);
OXEN_LOG(warn, "[on_send_raw_tx]: tx verification failed" << punctuation << reason);
OXEN_LOG(warn, "[on_send_raw_tx]: Failed to process tx" << punctuation << reason);
OXEN_LOG(info, (m_should_use_bootstrap_daemon ? "Using" : "Not using") << " the bootstrap daemon (our height: " << top_height << ", bootstrap daemon's height: " << *bootstrap_daemon_height << ")");
OXEN_LOG(error, "Could not query block at requested height: " << cryptonote::get_block_height(block.second));
OXEN_LOG(err, "Could not get state change from tx, possibly corrupt tx, hf_version "<< static_cast<int>(hard_fork_version));
OXEN_LOG(error, "Could not parse public key: " << req.pubkey);
OXEN_LOG(info, "Range proof verified failed for proof " << i);
OXEN_LOG(info, "Error in verRct: " << e.what());
OXEN_LOG(info, "Range proof verified failed for proof " << i);
OXEN_LOG(info, "Error in verRctSemanticsSimple: " << e.what());
OXEN_LOG(info, "verRctMGSimple/verRctCLSAGSimple failed for input " << i);
OXEN_LOG(info, "Error in verRctNonSemanticsSimple: " << e.what());
OXEN_LOG(debug, "Attempting to connect to " << to_string(a));
OXEN_LOG(debug, "Connected to " << to_string(a));
OXEN_LOG(debug, "HID " << (read ? '<' : '>') << " : " << oxenc::to_hex(buffer, buffer + block_len));
OXEN_LOG(debug,  "Looking for " <<
OXEN_LOG(debug,  (result == devices_list ? "SELECTED" : "SKIPPED ") <<
OXEN_LOG(debug, "Unable to enumerate device " << vid << ":" << pid << ": " << safe_hid_error(usb_device));
OXEN_LOG(debug, "Device " << id << " Created");
OXEN_LOG(debug, "Device " << id << " (tcp) created");
OXEN_LOG(debug, "Device " << id << " Destroyed");
OXEN_LOG(debug, "Ask for LOCKING for device " << name << " in thread ");
OXEN_LOG(debug, "Device " << name << " LOCKed");
OXEN_LOG(debug, "Ask for LOCKING(try) for device " << name << " in thread ");
OXEN_LOG(debug, "Device " << name << (r ? "" : " not") << " LOCKed(try)");
OXEN_LOG(debug, "Ask for UNLOCKING for device " << name << " in thread ");
OXEN_LOG(debug, "Device " << name << " UNLOCKed");
OXEN_LOG(debug, "CMD: " << cmd.str() << oxenc::to_hex(buffer_send + 5, buffer_send + length_send));
OXEN_LOG(debug, "RESP (+" << tools::short_duration(std::chrono::steady_clock::now() - last_cmd) << "): "
OXEN_LOG(debug, "send_secret: " << tx_in_progress);
OXEN_LOG(debug, "receive_secret: " << tx_in_progress);
OXEN_LOG(debug, "Device " << id <<" HIDUSB inited");
OXEN_LOG(debug, "Ledger wallet is set to " << coin << " " << nettype_string(device_nettype));
OXEN_LOG(debug, "Switch to mode: " << +static_cast<unsigned char>(m));
OXEN_LOG(debug, "get_transaction_prefix_hash [[IN]] h_x/1 " << h_x);
OXEN_LOG(debug, "ecdhEncode: Akout: "<<AKout_x);
OXEN_LOG(debug, "ecdhEncode: Akout: "<<AKout_x);
OXEN_LOG(error, "Device not found in registry: '" << device_descriptor << "'. Known devices: ");
OXEN_LOG(error, " - " << sm_pair.first);
OXEN_LOG(debug, msg << ": " << oxenc::to_hex(std::string_view{reinterpret_cast<const char*>(buff), len}));
OXEN_LOG(debug, msg << ": " << info);
OXEN_LOG(warn, language_name << " word '" << *it << "' is shorter than its prefix length, " << unique_prefix_length);
OXEN_LOG(warn, "Duplicate prefix in " << language_name << " word list: " << std::string(trimmed.data(), trimmed.size()));
OXEN_LOG(info, "Full match for language " << (*language)->get_english_language_name());
OXEN_LOG(info, "Fallback match for language " << (*language)->get_english_language_name());
OXEN_LOG(info, "Checksum is " << (ret ? "valid" : "invalid"));
OXEN_LOG(warn, "Could not disconnect and release: " << e.what());
OXEN_LOG(error, "Live refresh could not be terminated: " << e.what());
OXEN_LOG(warn, "Live refresh auto-finish failed: " << e.what());
OXEN_LOG(error, "Get public address exception: " << e.what());
OXEN_LOG(error, "Get secret keys exception: " << e.what());
OXEN_LOG(trace, "Batch " << cur << " / " << num_batches << " batches processed");
OXEN_LOG(error, "Could not detect if live refresh is enabled: " << e.what());
OXEN_LOG(warn, "KI computation state change failed, started: " << started << ", e: " << e.what());
OXEN_LOG(debug, "signed transaction: " << cryptonote::get_transaction_hash(cpend.tx) << "\n" << cryptonote::obj_to_json_str(cpend.tx) << "\n");
OXEN_LOG(info, "Trezor client version overriden by TREZOR_CLIENT_VERSION to: " << client_version);
OXEN_LOG(trace, "Already opened, count: " << m_open_counter);
OXEN_LOG(trace, "Negative open value: " << m_open_counter);
OXEN_LOG(debug, "Already closed. Counter " << m_open_counter);
OXEN_LOG(debug, "Bridge host: " << m_bridge_url);
OXEN_LOG(debug, "Device with idx " << device_idx << " is not supported. Vendor: " << id_vendor << ", product: " << id_product);
OXEN_LOG(error, "Could not detect vendor & product: " << e.what());
OXEN_LOG(debug, "Applied TREZOR_PATH: " << m_device_host << ":" << m_device_port);
OXEN_LOG(warn, "Error reading chunk, reason: " << e.what());
OXEN_LOG(warn, "Reading from UDP socket failed: " << ec.message());
OXEN_LOG(trace, "Libusb devices: " << cnt);
OXEN_LOG(error, "Unable to get libusb device descriptor " << i);
OXEN_LOG(trace, "Found Trezor device: " << desc.idVendor << ":" << desc.idProduct << " dev_idx " << (int)trezor_dev_idx);
OXEN_LOG(error, "Unable to get libusb device descriptor " << i);
OXEN_LOG(trace, "Found Trezor device: " << desc.idVendor << ":" << desc.idProduct
OXEN_LOG(error, "Could not release libusb interface: " << r);
OXEN_LOG(error, "BridgeTransport enumeration failed:" << e.what());
OXEN_LOG(error, "WebUsbTransport enumeration failed:" << e.what());
OXEN_LOG(error, "UdpTransport enumeration failed:" << e.what());
OXEN_LOG(error, "Could not disconnect and release: " << e.what());
OXEN_LOG(error, "Release exception: " << e.what());
OXEN_LOG(debug, "Enumeration yielded " << trans.size() << " Trezor devices");
OXEN_LOG(debug, "  device: " << *(cur.get()));
OXEN_LOG(debug, "Device Match: " << cur_path);
OXEN_LOG(error, "No matching Trezor device found. Device specifier: \"" << name << "\"");
OXEN_LOG(error, "Open exception: " << e.what());
OXEN_LOG(error, "Disconnect exception: " << e.what());
OXEN_LOG(trace, "Ask for LOCKING for device " << name << " in thread ");
OXEN_LOG(trace, "Device " << name << " LOCKed");
OXEN_LOG(trace, "Ask for LOCKING(try) for device " << name << " in thread ");
OXEN_LOG(trace, "Device " << name << " LOCKed(try)");
OXEN_LOG(debug, "Device " << name << " not LOCKed(try)");
OXEN_LOG(trace, "Ask for UNLOCKING for device " << name << " in thread ");
OXEN_LOG(trace, "Device " << name << " UNLOCKed");
OXEN_LOG(debug, "Ping response " << success->message());
OXEN_LOG(info, "Trezor does not respond: " << e.what());
OXEN_LOG(error, "Ping failed, exception thrown " << e.what());
OXEN_LOG(debug, "on_button_request, code: " << msg->code());
OXEN_LOG(debug, "appending to existing file with height: " << num_blocks-1 << "  total blocks: " << num_blocks);
OXEN_LOG(debug, "bootstrap::file_info size: " << bd.size());
OXEN_LOG(debug, "bootstrap::blocks_info size: " << bd.size());
// OXEN_LOG(trace, "chunk_size " << chunk_size);
OXEN_LOG(warn, "WARNING: chunk_size " << chunk_size << " > BUFFER_SIZE " << BUFFER_SIZE);
OXEN_LOG(debug, "flushed chunk:  chunk_size: " << chunk_size);
OXEN_LOG(info, "source blockchain height: " <<  m_blockchain_storage->get_current_blockchain_height()-1);
OXEN_LOG(info, "Using requested block height: " << requested_block_stop);
OXEN_LOG(info, "Using block height of source blockchain: " << block_stop);
OXEN_LOG(info, "Number of blocks exported: " << num_blocks_written);
OXEN_LOG(info, "Largest chunk: " << m_max_chunk << " bytes");
OXEN_LOG(info, "bootstrap::file_info size: " << buflen_file_info);
OXEN_LOG(info, "bootstrap file v" << unsigned(bfi.major_version) << "." << unsigned(bfi.minor_version));
OXEN_LOG(info, "bootstrap magic size: " << sizeof(file_magic));
OXEN_LOG(info, "bootstrap header size: " << bfi.header_size);
OXEN_LOG(debug, "chunk_size: " << chunk_size);
OXEN_LOG(warn, "WARNING: chunk_size " << chunk_size << " > BUFFER_SIZE " << BUFFER_SIZE
OXEN_LOG(debug, "NOTE: chunk_size " << chunk_size << " > " << CHUNK_SIZE_WARNING_THRESHOLD << " << height: "
OXEN_LOG(debug, "ERROR: chunk_size " << chunk_size << " <= 0" << "  height: " << h-1 << ", offset " << bytes_read);
OXEN_LOG(debug, "Number bytes scanned: " << bytes_read);
OXEN_LOG(info, "bootstrap file last block number: " << total_source_blocks-1 << " (zero-based height)  total blocks: " << total_source_blocks);
OXEN_LOG(info, "start block: " << start_height << "  stop block: " <<
OXEN_LOG(debug, "chunk_size: " << chunk_size);
OXEN_LOG(warn, "WARNING: chunk_size " << chunk_size << " > BUFFER_SIZE " << BUFFER_SIZE);
OXEN_LOG(info, "NOTE: chunk_size " << chunk_size << " > " << CHUNK_SIZE_WARNING_THRESHOLD);
OXEN_LOG(debug, "Total bytes read: " << bytes_read);
OXEN_LOG(info, "Specified block number reached - stopping.  block: " << h-1 << "  total blocks: " << h);
OXEN_LOG(debug, "loading block number " << h-1);
OXEN_LOG(debug, "loading block number " << h-1);
OXEN_LOG(debug, "block prev_id: " << b.prev_id << "\n");
OXEN_LOG(info, "Number of blocks imported: " << num_imported);
OXEN_LOG(info, "Finished at block: " << h-1 << "  total blocks: " << h);
OXEN_LOG(info, "verify:  " << std::boolalpha << opt_verify << std::noboolalpha);
OXEN_LOG(info, "batch:   " << std::boolalpha << opt_batch << std::noboolalpha
OXEN_LOG(info, "batch:   " << std::boolalpha << opt_batch << std::noboolalpha);
OXEN_LOG(info, "resume:  " << std::boolalpha << opt_resume  << std::noboolalpha);
OXEN_LOG(info, "nettype: " << (opt_testnet ? "testnet" : opt_devnet ? "devnet" : "mainnet"));
OXEN_LOG(info, "bootstrap file path: " << import_file_path);
OXEN_LOG(info, "database path:       " << m_config_folder);
OXEN_LOG(info, "height: " << core.get_blockchain_storage().get_current_blockchain_height());
OXEN_LOG(info, "height: " << core.get_blockchain_storage().get_current_blockchain_height());
OXEN_LOG(error, "Error renaming " << replacement_name << " to " << replaced_name << ": " << ec.message());
OXEN_LOG(error, "!! WARNING: Insufficient free space to extend database !!: " <<
OXEN_LOG(info, "Copying " << table);
OXEN_LOG(debug, block_height << "/" << blockchain_height << " is in tip");
OXEN_LOG(debug, "" << block_height << "/" << blockchain_height << " should be pruned, dropping");
OXEN_LOG(debug, "option: " << option);
OXEN_LOG(error, "Invalid db sync mode: " << db_sync_mode);
OXEN_LOG(error, "LMDB needs a directory path, but a file was passed: " << paths[1].string());
OXEN_LOG(error, "Failed to create directory: " << paths[1].string());
OXEN_LOG(info, "Loading blockchain from folder " << paths[n] << " ...");
OXEN_LOG(error, "Error opening database: " << e.what());
OXEN_LOG(info, source_dest << " blockchain storage initialized OK");
OXEN_LOG(error, "Blockchain is already pruned, use --" << arg_copy_pruned_database.name << " to copy it anyway");
OXEN_LOG(info, "Swapping databases, pre-pruning blockchain will be left in " << paths[0].string() + "-old and can be removed if desired");
OXEN_LOG(warn, "Bad vin type in txid " << get_transaction_hash(tx));
OXEN_LOG(warn, "Bad vout type in txid " << get_transaction_hash(tx));
//OXEN_LOG(error, "txid ancestry not found: " << txid);
OXEN_LOG(warn, "Failed to get txid " << txid << " from db");
OXEN_LOG(warn, "Bad tx: " << txid);
OXEN_LOG(warn, "Bad vout type in txid " << cryptonote::get_transaction_hash(b.miner_tx));
OXEN_LOG(warn, "Loading blockchain from folder " << filename << " ...");
OXEN_LOG(warn, "Error opening database: " << e.what());
OXEN_LOG(warn, "Loading state data from " << state_file_path);
OXEN_LOG(error, "Failed to load state data from " << state_file_path << ", restarting from scratch");
OXEN_LOG(info, "Starting from height " << state.height);
OXEN_LOG(warn, "Failed to get txid " << txid << " from db");
OXEN_LOG(warn, "Bad tx: " << txid);
OXEN_LOG(info, txid << ": " << ancestry_size);
OXEN_LOG(info, "Height " << h << ": " << (block_ancestry_size / txids.size()) << " average over " << txids.size() << stats_msg);
OXEN_LOG(warn, "Saving state data to " << state_file_path);
OXEN_LOG(error, "Failed to save state data to " << state_file_path);
OXEN_LOG(warn, "The state file is only built up to height " << state.height << ", but the blockchain reached height " << db_height);
OXEN_LOG(warn, "Checking ancestry for txid " << start_txid);
OXEN_LOG(debug, "adding txid: " << output_txid);
OXEN_LOG(info, "Ancestry for " << start_txid << ": " << get_deduplicated_ancestry(ancestry) << " / " << get_full_ancestry(ancestry));
OXEN_LOG(info, cryptonote::print_money(i.first.amount) << "/" << i.first.offset << ": " << i.second);
OXEN_LOG(info, "cache: txes " << std::to_string(cached_txes*100./total_txes)
OXEN_LOG(debug, "option: " << option);
OXEN_LOG(error, "!! WARNING: Insufficient free space to extend database !!: " << (si.available / 1000000) << " MB available");
OXEN_LOG(info, "Creating spent output cache in " << cache_filename);
OXEN_LOG(warn, "Failed to create output cache directory " << cache_filename << ": " << ec.message());
OXEN_LOG(err, "Failed to parse transaction from blob: " << e.what());
OXEN_LOG(info, "Ring has duplicate member(s): " << tools::join(" ", v));
OXEN_LOG(warn, "Failed to create lmdb path " << filename << ": " << ec.message());
OXEN_LOG(info, "Opening oxen blockchain at " << filename);
OXEN_LOG(error, "Failed to load outputs from " << filename << ": " << strerror(errno));
OXEN_LOG(error, "Error reading from " << filename << ": " << strerror(errno));
OXEN_LOG(error, "Bad format in " << filename);
OXEN_LOG(error, "Bad format in " << filename);
OXEN_LOG(error, "Failed to open " << filename << ": " << strerror(errno));
OXEN_LOG(error, "Failed to enumerate spent outputs: " << mdb_strerror(dbr));
OXEN_LOG(error, "Invalid db sync mode: " << db_sync_mode);
OXEN_LOG(warn, window_front << "-" << window_back << ": " << (100.0f * outs_spent / outs_total) << "% ( " << outs_spent << " / " << outs_total << " )");
OXEN_LOG(warn, window_front << "-" << window_back << ": " << (100.0f * outs_spent / outs_total) << "% ( " << outs_spent << " / " << outs_total << " )");
OXEN_LOG(info, "Adding " << extra_spent_outputs.size() << " extra spent outputs");
OXEN_LOG(warn, "First diverging transaction at " << start_idx);
OXEN_LOG(warn, "Reading blockchain from " << inputs[n] << " from " << start_idx);
OXEN_LOG(info, "Marking output " << output.first << "/" << output.second << " as spent, due to being used in a 1-ring");
OXEN_LOG(info, "Marking output " << output.first << "/" << output.second << " as spent, due to being used in " << new_ring.size() << " identical " << new_ring.size() << "-rings");
OXEN_LOG(info, "Marking output " << output.first << "/" << output.second << " as spent, due to as many outputs of that amount being spent as exist so far");
OXEN_LOG(info, "Marking output " << output.first << "/" << output.second << " as spent, due to being used in " << new_ring.size() << " subsets of " << new_ring.size() << "-rings");
OXEN_LOG(debug, "Key image " << txin.k_image << " already seen: "
OXEN_LOG(info, "Marking output " << output.first << "/" << output.second << " as spent, due to being used in rings with a single common element");
OXEN_LOG(warn, "blockchain from " << inputs[n] << " processed till tx idx " << start_idx);
OXEN_LOG(warn, "Secondary pass on " << work_spent.size() << " spent outputs");
OXEN_LOG(info, "Marking output " << output.first << "/" << output.second << " as spent, due to being used in a " <<
OXEN_LOG(warn, std::to_string(diff) << " new outputs marked as spent, " << get_num_spent_outputs() << " total outputs marked as spent");
OXEN_LOG(info, "Total pre-rct outputs: " << pre_rct);
OXEN_LOG(info, "Total rct outputs: " << rct);
OXEN_LOG(info, key.key << ": " << data << " (" << percent << "%)");
OXEN_LOG(warn, "Loading blockchain from folder " << filename << " ...");
OXEN_LOG(warn, "Error opening database: " << e.what());
OXEN_LOG(warn, "Checking depth for txid " << start_txid);
OXEN_LOG(warn, "Considering "<< txids.size() << " transaction(s) at depth " << depth);
OXEN_LOG(warn, "Failed to get txid " << txid << " from db");
OXEN_LOG(warn, "Bad tx: " << txid);
OXEN_LOG(debug, txid << " is a coinbase transaction");
OXEN_LOG(debug, "adding txid: " << cryptonote::get_transaction_hash(b.miner_tx));
OXEN_LOG(warn, "Bad vout type in txid " << cryptonote::get_transaction_hash(b.miner_tx));
OXEN_LOG(warn, "Failed to get txid " << block_txid << " from db");
OXEN_LOG(warn, "Bad tx: " << block_txid);
OXEN_LOG(debug, "adding txid: " << block_txid);
OXEN_LOG(warn, "Bad vout type in txid " << block_txid);
OXEN_LOG(warn, "Bad vin type in txid " << txid);
OXEN_LOG(warn, "Min depth for txid " << start_txid << ": " << depth);
OXEN_LOG(warn, "Average min depth for " << start_txids.size() << " transaction(s): " << cumulative_depth/(float)depths.size());
OXEN_LOG(warn, "Median min depth for " << start_txids.size() << " transaction(s): " << tools::median(std::move(depths)));
OXEN_LOG(warn, "Export output file: " << output_file_path.string());
OXEN_LOG(warn, "Loading blockchain from folder " << filename << " ...");
OXEN_LOG(warn, "Error opening database: " << e.what());
OXEN_LOG(error, "Failed to load outputs from " << filename << ": " << strerror(errno));
OXEN_LOG(error, "Bad format in " << filename);
OXEN_LOG(error, "Bad format in " << filename);
OXEN_LOG(warn, "Loading blockchain from folder " << filename << " ...");
OXEN_LOG(warn, "Error opening database: " << e.what());
OXEN_LOG(info, "Ignoring output value " << i->first << ", with " << num_outputs << " outputs");
OXEN_LOG(info, i->first << ": " << i->second << "/" << num_outputs);
OXEN_LOG(error, "More outputs are spent than known for amount " << i->first << ", not touching");
OXEN_LOG(info, "Pruning data for " << num_outputs << " outputs");
OXEN_LOG(info, "Total outputs: " << num_total_outputs);
OXEN_LOG(info, "Known spent outputs: " << num_known_spent_outputs);
OXEN_LOG(info, "Eligible outputs: " << num_eligible_outputs);
OXEN_LOG(info, "Eligible known spent outputs: " << num_eligible_known_spent_outputs);
OXEN_LOG(info, "Prunable outputs: " << num_prunable_outputs);
OXEN_LOG(warn, "Loading blockchain from folder " << filename << " ...");
OXEN_LOG(warn, "Error opening database: " << e.what());
OXEN_LOG(warn, "Reading blockchain from " << input);
OXEN_LOG(info, std::to_string(c.second) << " outputs used " << c.first << " times (" << percent << "%)");
OXEN_LOG(warn, "Loading blockchain from folder " << filename << " ...");
OXEN_LOG(warn, "Error opening database: " << e.what());
OXEN_LOG(info, "Starting from height " << block_start << ", stopping at height " << block_stop);
OXEN_LOG(info, "source blockchain height: " <<  m_blockchain_storage->get_current_blockchain_height()-1);
OXEN_LOG(info, "Using requested block height: " << requested_block_stop);
OXEN_LOG(info, "Using block height of source blockchain: " << block_stop);
OXEN_LOG(info, "Number of blocks exported: " << num_blocks_written);
OXEN_LOG(debug, "estimated bulletproof rct tx size for " << n_inputs << " inputs with ring size " << (mixin+1) << " and " << n_outputs << " outputs: " << size << " (" << ((32 * n_inputs/*+1*/) + 2 * 32 * (mixin+1) * n_inputs + 32 * n_outputs) << " saved)");
OXEN_LOG(debug, "clawback on size " << size << ": " << bp_clawback);
OXEN_LOG(info, "Decrypted payment ID: " << payment_id);
OXEN_LOG(trace, "Picking 1/" << n_rct << " in block " << index);
OXEN_LOG(info, "set daemon to " << (url.empty() ? "(none, offline)" : url));
OXEN_LOG(debug, "Setting SPENT at " << height << ": ki " << td.m_key_image << ", amount " << print_money(td.m_amount));
OXEN_LOG(debug, "Setting UNSPENT: ki " << td.m_key_image << ", amount " << print_money(td.m_amount));
OXEN_LOG(err, __func__ << ": Unsupported rct type: " << (int)rv.type);
OXEN_LOG(err, "Failed to decode input " << i);
OXEN_LOG(warn, "Transaction extra has unsupported format: " << txid);
OXEN_LOG(error, "PROC NEW TX " << txid);
OXEN_LOG(warn, "Transaction extra has unsupported format: " << txid);
OXEN_LOG(warn, "Public key wasn't found in the transaction extra. Skipping transaction " << txid);
OXEN_LOG(warn, "Failed to generate key derivation from tx pubkey in " << txid << ", skipping");
OXEN_LOG(warn, "Failed to generate key derivation from additional tx pubkey in " << txid << ", skipping");
OXEN_LOG(warn, "Received money: " << print_money(td.amount()) << ", with tx: " << txid);
OXEN_LOG(err, +transfer.m_spent << " || " << transfer.amount() << " >= " << tx_scan_info[o].amount);
OXEN_LOG(err, "Public key " << tools::type_to_hex(kit->first)
OXEN_LOG(info, "Public key " << tools::type_to_hex(kit->first)
OXEN_LOG(err, "Public key " << tools::type_to_hex(kit->first)
OXEN_LOG(err, "Public key " << tools::type_to_hex(kit->first)
OXEN_LOG(warn, "Received money: " << print_money(transfer.amount()) << ", with tx: " << txid);
OXEN_LOG(error, "Inconsistent amount in tx input: got " << print_money(amount) <<
OXEN_LOG(warn, "Spent money: " << print_money(amount) << ", with tx: " << txid);
OXEN_LOG(debug, "Found encrypted payment ID: " << payment_id8);
OXEN_LOG(warn, "Failed to decrypt payment ID: " << payment_id8);
OXEN_LOG(debug, "Decrypted payment ID: " << payment_id8);
OXEN_LOG(debug, "Found unencrypted payment ID in tx " << txid << " (ignored)");
OXEN_LOG(debug, "Found unencrypted payment ID: " << payment_id);
OXEN_LOG(debug, "Payment found in " << (pool ? blink ? "blink pool" : "pool" : "block") << ": " << payment_id << " / " << payment.m_tx_hash << " / " << payment.m_amount);
OXEN_LOG(warn, "Blockchain sync progress: " << bl_id << ", height " << height);
OXEN_LOG(debug, "Processed block: " << bl_id << ", height " << height << ", " <<  miner_tx_handle_time + txs_handle_time << "(" << miner_tx_handle_time << "/" << txs_handle_time <<")ms");
OXEN_LOG(debug,  "Skipped block by timestamp, height: " << height << ", block time " << b.timestamp << ", account time " << m_account.get_createtime());
OXEN_LOG(debug, "Pulling blocks: start_height " << start_height);
OXEN_LOG(debug, "Pulled blocks: blocks_start_height " << blocks_start_height << ", count " << blocks.size()
OXEN_LOG(debug, "Block is already in blockchain: " << tools::type_to_hex(bl_id));
OXEN_LOG(debug, "Removing " << txid << " from unconfirmed payments, not found in pool");
OXEN_LOG(warn, "Long poll request failed: " << e.what());
OXEN_LOG(info, "Pending txid " << txid << " not in pool, marking as not in pool");
OXEN_LOG(info, "Pending txid " << txid << " not in pool, marking as failed");
OXEN_LOG(info, "Resetting spent status for output " << vini << ": " << td.m_key_image);
OXEN_LOG(debug, "Already seen " << txid << ", and not for us, skipped");
OXEN_LOG(info, "Found new pool tx: " << txid);
OXEN_LOG(warn, "Failed to retrieve transactions: " << e.what());
OXEN_LOG(error, "Got txid " << tx_hash << " which we did not ask for");
OXEN_LOG(error, "Blocks start before blockchain offset: " << blocks_start_height << " " << m_blockchain.offset());
OXEN_LOG(debug,  "Skipped block by height: " << current_index);
OXEN_LOG(error, "Error parsing blocks: " << e.what());
OXEN_LOG(info, "Another try pull_blocks (try_count=" << try_count << ")...");
OXEN_LOG(err, "pull_blocks failed, try_count=" << try_count);
OXEN_LOG(info, "Refresh done, blocks received: " << blocks_fetched << ", balance (all accounts): " << print_money(balance_all(false)) << ", unlocked: " << print_money(unlocked_balance_all(false)));
OXEN_LOG(warn, "Failed to request output distribution: " << res.status);
OXEN_LOG(warn, "Detaching blockchain on height " << height);
OXEN_LOG(info, "Resetting spent/frozen status for output " << i << ": " << td.m_key_image);
OXEN_LOG(warn, "Detached blockchain on height " << height << ", transfers detached " << transfers_detached << ", blocks detached " << blocks_detached);
OXEN_LOG(err, "failed to update wallet keys file " << keys_file_name);
OXEN_LOG(err, "failed to serialize wallet multisig signers: " << e.what());
OXEN_LOG(err, "Field multisig_signers found in JSON, but failed to parse: " << e.what());
OXEN_LOG(err, "Field multisig_derivations found in JSON, but failed to parse: " << e.what());
OXEN_LOG(warn, "Unknown refresh-type value (" << field_refresh_type << "), using default");
OXEN_LOG(warn, "Loaded wallet keys file, with public address: " << m_account.get_public_address_str(m_nettype));
OXEN_LOG(warn, "file not found: " << m_wallet_file << ", starting with empty blockchain");
OXEN_LOG(debug, "trimming to " << height << ", offset " << m_blockchain.offset());
OXEN_LOG(err, "error removing file: " << old_address_file << ": " << ec.message());
OXEN_LOG(err, "error removing file: " << old_file << ": " << ec.message());
OXEN_LOG(err, "error removing file: " << old_keys_file << ": " << ec.message());
OXEN_LOG(err, "error removing file: " << m_mms_file << ": " << ec.message());
OXEN_LOG(debug, "Getting transfers of type(s) " << (args.in ? "in " : "") << (args.out ? "out " : "") << (args.pending ? "pending " : "") << (args.failed ? "failed " : "")
OXEN_LOG(debug, "Resolved ONS name: "<< address << " to address: " << get_account_address_as_str(m_nettype, info.is_subaddress, info.address));
OXEN_LOG(debug, "Invalid address format, could not resolve " << address);
OXEN_LOG(debug, "Calling is_key_image_spent on " << start_offset << " - " << (start_offset + n_outputs - 1) << ", out of " << m_transfers.size());
OXEN_LOG(warn, "Marking output " << i << "(" << td.m_key_image << ") as unspent, it was marked as spent");
OXEN_LOG(warn, "Marking output " << i << "(" << td.m_key_image << ") as spent, it was marked as unspent");
OXEN_LOG(error, "Failed to parse hex representation of key image: " << entry.key_image);
OXEN_LOG(error, "Failed to parse hex representation of key image: " << contribution.key_image);
OXEN_LOG(debug, "transaction " << txid << " generated ok and sent to daemon, key_images: [" << ptx.key_images << "]");
OXEN_LOG(info, "Transaction successfully " << (blink ? "blinked. " : "sent. ") << txid
OXEN_LOG(warn, "saving " << ptx_vector.size() << " transactions");
OXEN_LOG(warn, "saving " << ptx_vector.size() << " transactions");
OXEN_LOG(debug, "Saving unsigned tx data: " << oss.str());
OXEN_LOG(warn, "File " << unsigned_filename << " does not exist: " << ec.message());
OXEN_LOG(warn, "Failed to load from " << unsigned_filename);
OXEN_LOG(warn, "Failed to decrypt unsigned tx: " << e.what());
OXEN_LOG(info, "Loaded tx unsigned data from binary: " << exported_txs.txes.size() << " transactions");
OXEN_LOG(info, " " << (n+1) << ": " << sd.sources.size() << " inputs, ring size " << sd.sources[0].outputs.size());
OXEN_LOG(warn, "Failed to generate key derivation from tx pubkey in " << cryptonote::get_transaction_hash(tx) << ", skipping");
OXEN_LOG(warn, "Failed to generate key derivation from additional tx pubkey in " << cryptonote::get_transaction_hash(tx) << ", skipping");
OXEN_LOG(warn, "WARNING: key image not known in signing wallet at index " << i);
OXEN_LOG(warn, "Failed to save file to " << signed_filename);
OXEN_LOG(warn, "Failed to save file to " << raw_filename);
OXEN_LOG(trace, "Saving signed tx data (with encryption): " << oss.str());
OXEN_LOG(warn, "File " << signed_filename << " does not exist: " << ec);
OXEN_LOG(warn, "Failed to load from " << signed_filename);
OXEN_LOG(warn, "Failed to decrypt signed transaction: " << e.what());
OXEN_LOG(warn, "Loaded signed tx data from binary: " << signed_txs.ptx.size() << " transactions");
OXEN_LOG(warn, "saving " << txs.m_ptx.size() << " multisig transactions");
OXEN_LOG(debug, "Saving multisig unsigned tx data: " << oss.str());
OXEN_LOG(warn, "Failed to decrypt multisig tx data: " << e.what());
OXEN_LOG(info, "Loaded multisig tx unsigned data from binary: " << exported_txs.m_ptx.size() << " transactions");
OXEN_LOG(warn, "File " << filename << " does not exist: " << ec.message());
OXEN_LOG(warn, "Failed to load from " << filename);
OXEN_LOG(warn, "Failed to parse multisig tx data from " << filename);
OXEN_LOG(info, " " << (n+1) << ": " << sd.sources.size() << " inputs, mixin " << (sd.sources[0].outputs.size()-1) <<
OXEN_LOG(info, "Failed to query base fee, using " << print_money(fees.first) << "/byte + " << print_money(fees.second) << "/output");
OXEN_LOG(info, "ringdb path set to " << m_ring_database.u8string());
OXEN_LOG(error, "Failed to initialize ringdb: " << e.what());
OXEN_LOG(debug, "Found " << std::to_string(txs_hashes.size()) << " transactions");
OXEN_LOG(debug, "Scanning " << res.txs.size() << " transactions");
OXEN_LOG(info, "Found and saved rings for " << txs_hashes.size() << " transactions");
OXEN_LOG(debug, m_keys_file << " is already locked.");
OXEN_LOG(debug, m_keys_file << " is already unlocked.");
OXEN_LOG(warn, "Key " << output_public_key << " at index " << global_index << " is not in the main subgroup");
OXEN_LOG(warn, "Commitment " << mask << " at index " << global_index << " is not in the main subgroup");
OXEN_LOG(debug, "fake_outputs_count: " << fake_outputs_count);
OXEN_LOG(debug, "base_requested_outputs_count: " << base_requested_outputs_count);
OXEN_LOG(debug, "Found " << print_money(amount) << ": " << he.total_instances << " total, "
OXEN_LOG(info, "" << num_outs << " unlocked outputs of size " << print_money(amount));
OXEN_LOG(info, "" << num_outs << " unlocked rct outputs");
OXEN_LOG(info, "Fake output makeup: " << requested_outputs_count << " requested: " << recent_outputs_count << " recent, " <<
OXEN_LOG(info, "This output has a known ring, reusing (size " << ring.size() << ")");
OXEN_LOG(info, "Ring has output " << out);
OXEN_LOG(info, "Ignoring output " << out << ", too recent");
OXEN_LOG(info, "Selecting real output: " << td.m_global_output_index << " for " << print_money(amount));
OXEN_LOG(debug, "Starting gamma picking with " << num_outs << ", num_usable_outs " << num_usable_outs
OXEN_LOG(debug, "picked " << i << ", " << num_found << " now picked");
OXEN_LOG(debug, "picking " << pick.first << " outputs:" << outputs);
OXEN_LOG(debug, "asking for outputs with amount " << print_money(o.first) << ":" << outputs);
OXEN_LOG(debug, "Index " << i << "/" << requested_outputs_count << ": idx " << get_outputs[i].index << " (real " << td.m_global_output_index << "), unlocked " << got_outs[i].unlocked << ", key " << got_outs[i].key << " (from existing ring)");
OXEN_LOG(debug, "Looking for " << (fake_outputs_count+1) << " outputs of size " << print_money(td.is_rct() ? 0 : td.amount()));
OXEN_LOG(debug, "Index " << i << "/" << requested_outputs_count << ": idx " << get_outputs[i].index << " (real " << td.m_global_output_index << "), unlocked " << got_outs[i].unlocked << ", key " << got_outs[i].key);
OXEN_LOG(error, "Failed to set ring for " << td.m_key_image);
OXEN_LOG(debug, "transfer_selected_rct: starting with fee " << print_money (needed_money));
OXEN_LOG(debug, "selected transfers: " << tools::join(" ", selected_transfers));
OXEN_LOG(debug, "transfer: adding " << print_money(dt.amount) << ", for a total of " << print_money (needed_money));
OXEN_LOG(debug, "We can use " << n_available_signers << "/" << m_multisig_signers.size() <<  " other signers");
OXEN_LOG(debug, "We will create " << n_multisig_txes << " txes");
OXEN_LOG(debug, "wanted " << print_money(needed_money) << ", found " << print_money(found_money) << ", fee " << print_money(fee));
OXEN_LOG(warn, "amount=" << cryptonote::print_money(src.amount) << ", real_output=" <<src.real_output << ", real_output_in_tx_index=" << src.real_output_in_tx_index << ", indexes:" << indexes);
OXEN_LOG(debug, "constructed tx, r="<<r);
OXEN_LOG(debug, "constructed tx, r="<<r);
OXEN_LOG(debug, "pick_preferred_rct_inputs: needed_money " << print_money(needed_money));
OXEN_LOG(debug, "Ignoring output " << i << " of amount " << print_money(td.amount()) << " which is outside prescribed range [" << print_money(m_ignore_outputs_below) << ", " << print_money(m_ignore_outputs_above) << "]");
OXEN_LOG(debug, "We can use " << i << " alone: " << print_money(td.amount()));
OXEN_LOG(debug, "Ignoring output " << i << " of amount " << print_money(td.amount()) << " which is outside prescribed range [" << print_money(m_ignore_outputs_below) << ", " << print_money(m_ignore_outputs_above) << "]");
OXEN_LOG(debug, "Considering input " << i << ", " << print_money(td.amount()));
OXEN_LOG(debug, "Ignoring output " << j << " of amount " << print_money(td2.amount()) << " which is outside prescribed range [" << print_money(m_ignore_outputs_below) << ", " << print_money(m_ignore_outputs_above) << "]");
OXEN_LOG(debug, "  with input " << j << ", " << print_money(td2.amount()) << ", relatedness " << relatedness);
OXEN_LOG(warn, "we could use " << i << " and " << j);
OXEN_LOG(debug, out.outputs.size() << " outputs for amount "+ std::to_string(out.amount) + " received from light wallet node");
OXEN_LOG(debug, "selected transfers size: " << selected_transfers.size());
OXEN_LOG(debug, "added real output " << tools::type_to_hex(td.get_public_key()));
OXEN_LOG(debug, "Looking for " << (fake_outputs_count+1) << " outputs with amounts " << print_money(td.is_rct() ? 0 : td.amount()));
OXEN_LOG(debug, "OUTS SIZE: " << outs.back().size());
OXEN_LOG(debug, "Index " << i << "/" << light_wallet_requested_outputs_count << ": idx " << ores.amount_outs[amount_key].outputs[i].global_index << " (real " << td.m_global_output_index << "), unlocked " << "(always in light)" << ", key " << ores.amount_outs[0].outputs[i].public_key);
OXEN_LOG(debug, "added fake output " << ores.amount_outs[amount_key].outputs[i].public_key);
OXEN_LOG(debug, "index " << global_index);
OXEN_LOG(trace, outs.back().size() << " outputs added. Sorting outputs by index:");
OXEN_LOG(debug, "Status: " << response.status);
OXEN_LOG(debug, "Reason: " << response.reason);
OXEN_LOG(debug, "New wallet: " << response.new_address);
OXEN_LOG(debug, "FOUND " << ores.outputs.size() <<" outputs");
OXEN_LOG(trace, "Output " << o.public_key << " is spent. Key image: " <<  ski);
OXEN_LOG(trace, "Unspent output found. " << o.public_key);
OXEN_LOG(debug, "output index: " << o.global_index);
OXEN_LOG(debug, "amount: " << td.amount());
OXEN_LOG(debug, "Adjusting amount sent/received for tx: <" + t.hash + ">. Is tx sent to own wallet? " << print_money(amount_sent) << " != " << print_money(confirmed_tx->second.m_amount_in));
OXEN_LOG(debug, "transfer: adding " << print_money(dt.amount) << ", for a total of " << print_money (needed_money));
OXEN_LOG(debug, "Candidate subaddress index for spending: " << i);
OXEN_LOG(debug, "Ignoring output " << i << " of amount " << print_money(td.amount()) << " which is outside prescribed range [" << print_money(m_ignore_outputs_below) << ", " << print_money(m_ignore_outputs_above) << "]");
OXEN_LOG(debug, "Starting with " << num_nondust_outputs << " non-dust outputs and " << num_dust_outputs << " dust outputs");
OXEN_LOG(info, "Found preferred rct inputs for rct tx: " << s);
OXEN_LOG(debug, "Start of loop with " << unused_transfers_indices->size() << " " << unused_dust_indices->size() << ", tx.dsts.size() " << tx.dsts.size());
OXEN_LOG(debug, "unused_transfers_indices: " << tools::join(" ", *unused_transfers_indices));
OXEN_LOG(debug, "unused_dust_indices: " << tools::join(" ", *unused_dust_indices));
OXEN_LOG(debug, "dsts size " << dsts.size() << ", first " << (dsts.empty() ? "-" : cryptonote::print_money(dsts[0].amount)));
OXEN_LOG(debug, "adding_fee " << adding_fee);
OXEN_LOG(debug, "Second output was not strictly needed, and we're running out of outputs above " << print_money(min_output_value) << ", not adding");
OXEN_LOG(debug, "Second output was not strictly needed, and relatedness " << relatedness << ", not adding");
OXEN_LOG(debug, "Picking output " << idx << ", amount " << print_money(td.amount()) << ", ki " << td.m_key_image);
OXEN_LOG(debug, "We can fully pay " << get_account_address_as_str(m_nettype, dsts[0].is_subaddress, dsts[0].addr) <<
OXEN_LOG(debug, "We can partially pay " << get_account_address_as_str(m_nettype, dsts[0].is_subaddress, dsts[0].addr) <<
OXEN_LOG(debug, "Considering whether to create a tx now, " << tx.selected_transfers.size() << " inputs, tx limit "
OXEN_LOG(debug, "Trying to create a tx now, with " << tx.dsts.size() << " outputs and " <<
OXEN_LOG(debug, "Made a " << get_weight_string(test_ptx.tx, txBlob.size()) << " tx, with " << print_money(available_for_fee) << " available for fee (" <<
OXEN_LOG(debug, "Adjusting amount paid to " << get_account_address_as_str(m_nettype, i->is_subaddress, i->addr) << " from " <<
OXEN_LOG(debug, "We made a tx, adjusting fee and saving it, we need " << print_money(needed_fee) << " and we have " << print_money(test_ptx.fee));
OXEN_LOG(debug, "Made an attempt at a  final " << get_weight_string(test_ptx.tx, txBlob.size()) << " tx, with " << print_money(test_ptx.fee) <<
OXEN_LOG(debug, "Made a final " << get_weight_string(test_ptx.tx, txBlob.size()) << " tx, with " << print_money(test_ptx.fee) <<
OXEN_LOG(info, "Done creating " << txes.size() << " transactions, " << print_money(accumulated_fee) <<
OXEN_LOG(info, "  Transaction " << (1+std::distance(txes.begin(), i)) << "/" << txes.size() <<
OXEN_LOG(debug, "sanity_check: " << ptx_vector.size() << " txes, " << dsts.size() << " destinations");
OXEN_LOG(debug, "Adding " << cryptonote::print_money(change) << " expected change");
OXEN_LOG(debug, "Spending from subaddress index " << i->first);
OXEN_LOG(debug, "Spending from subaddress index " << p.first);
OXEN_LOG(debug, "Starting with " << unused_transfers_indices.size() << " non-dust outputs and " << unused_dust_indices.size() << " dust outputs");
OXEN_LOG(debug, "Picking output " << idx << ", amount " << print_money(td.amount()));
OXEN_LOG(debug, "Considering whether to create a tx now, " << tx.selected_transfers.size() << " inputs, tx limit "
OXEN_LOG(debug, "Trying to create a tx now, with " << tx.dsts.size() << " destinations and " <<
OXEN_LOG(debug, "Made a " << get_weight_string(test_ptx.tx, txBlob.size()) << " tx, with " << print_money(available_for_fee) << " available for fee (" <<
OXEN_LOG(debug, "Made an attempt at a final " << get_weight_string(test_ptx.tx, txBlob.size()) << " tx, with " << print_money(test_ptx.fee) <<
OXEN_LOG(debug, "Made a final " << get_weight_string(test_ptx.tx, txBlob.size()) << " tx, with " << print_money(test_ptx.fee) <<
OXEN_LOG(info, "Done creating " << txes.size() << " transactions, " << print_money(accumulated_fee) <<
OXEN_LOG(info, "  Transaction " << (1+std::distance(txes.begin(), i)) << "/" << txes.size() <<
OXEN_LOG(debug, "Signed tx data from hw: " << exported_txs.ptx.size() << " transactions");
OXEN_LOG(debug, "Using v" << (unsigned)version << " rules");
OXEN_LOG(debug, "Not using v" << (unsigned)version << " rules");
OXEN_LOG(debug, "tx key cached for txid: " << txid);
OXEN_LOG(debug, "Aux data not found for txid: " << txid);
OXEN_LOG(debug, "Empty tx keys for txid: " << txid);
OXEN_LOG(debug, "Calculated blockchain height: " << approx_blockchain_height);
OXEN_LOG(debug, "Transfer " << i << ": " << print_money(amount) << " (" << td.m_global_output_index << "): "
OXEN_LOG(debug, "Total: " << print_money(spent) << " spent, " << print_money(unspent) << " unspent");
OXEN_LOG(warn, "Spent money: " << print_money(amount) << ", with tx: " << *spent_txid);
OXEN_LOG(warn, "WARNING: imported key image differs from previously known key image at index " << ki_idx << ": trusting imported one");
OXEN_LOG(debug, "update_multisig_rescan_info: updating index " << n);
OXEN_LOG(info, i.size() << " outputs found");
OXEN_LOG(info, "Multisig info importing from block height " << td.m_block_height);
OXEN_LOG(info, "Invalid HTTP request for " << req->getMethod() << " " << req->getUrl());
OXEN_LOG(info, "Invalid JSON RPC request from " << get_remote_address(res) << ": no 'method' in request");
OXEN_LOG(info, "Invalid JSON RPC request from " << get_remote_address(res) << ": method '" << method << "' is invalid");
OXEN_LOG(debug, "Incoming JSON RPC request for " << method << " from " << get_remote_address(res));
OXEN_LOG(warn, "JSON RPC request for restricted command " << method << " in restricted mode from " << get_remote_address(res));
OXEN_LOG(err, "Exception while refreshing: " << ex.what());
OXEN_LOG(debug, "Not starting long poll thread: " << (m_long_poll_thread.joinable() ? "already running" : "long polling disabled"));
OXEN_LOG(error, "Failed to process rpc arguments: " << e.what());
OXEN_LOG(error, "Invalid port " << port << " specified");
OXEN_LOG(error, arg_wallet_dir.name << " and " << wallet_args::arg_wallet_file().name << " are incompatible, use only one of them");
OXEN_LOG(err, tr("Failed to create directory ") << m_wallet_dir << ": " << ec.message());
OXEN_LOG(err, tr("Cannot specify --") << arg_disable_rpc_login.name << tr(" and --") << arg.rpc_login.name);
OXEN_LOG(err, tr("Failed to create file ") << temp << tr(". Check permissions or remove file"));
OXEN_LOG(err, tr("Error writing to file ") << temp);
OXEN_LOG(warn, tr("RPC username/password is stored in file ") << temp);
OXEN_LOG(info, "Auto refresh now " << (m_auto_refresh_period != 0s ? std::to_string(std::chrono::duration<float>(m_auto_refresh_period).count()) + " seconds" : std::string("disabled")));
OXEN_LOG(warn, "Got back invalid entry_index " << rec.entry_index << " for a request for " << num_entries << " entries");
OXEN_LOG(warn, "Failed to decrypt ONS value for " << res_e.name << (errmsg.empty() ? ""s : ": " + errmsg));
OXEN_LOG(err, tr("Wallet initialization failed: ") << e.what());
OXEN_LOG(err, tools::wallet_rpc_server::tr("Failed to run wallet: ") << e.what());
OXEN_LOG(err, tools::wallet_rpc_server::tr("Failed to save wallet: ") << e.what());
OXEN_LOG(warn, "No authorized signer with Monero address " << account_address_to_string(monero_address));
OXEN_LOG(warn, "No authorized signer with label " << label);
OXEN_LOG(warn, "No message found with an id of " << id);
OXEN_LOG(info, "No message store file found: " << filename);
OXEN_LOG(error, "MMS file " << filename << " has bad structure <iv,encrypted_data>: " << e.what());
OXEN_LOG(error, "MMS file " << filename << " has bad structure: " << e.what());
OXEN_LOG(error, "HTTP request failed: " << e.what());
OXEN_LOG(error, "!! WARNING: Insufficient free space to extend database !!: " << (si.available / 1000000) << " MB available");
OXEN_LOG(warn, "Failed to create ringdb directory " << filename_ << ": " << ec.message());
OXEN_LOG(debug, "Removing ring data for key image " << key_image);
OXEN_LOG(debug, "Found ring for key image " << key_image << ":");
OXEN_LOG(debug, "Relative: " << tools::join(" ", outs));
OXEN_LOG(debug, "Absolute: " << tools::join(" ", outs));
OXEN_LOG(debug, "Marking output " << output.first << "/" << output.second << " as spent");
OXEN_LOG(debug, "Marking output " << output.first << "/" << output.second << " as unspent");
OXEN_LOG(err, "THROW EXCEPTION: " << #err_type);                                                 \
OXEN_LOG(err, #cond << ". THROW EXCEPTION: " << #err_type);                                                 \
OXEN_LOG(error, wallet_args::tr("Can't find config file ") << config);
OXEN_LOG(info, "Setting log level = " << command_line::get_arg(vm, arg_log_level));
OXEN_LOG(info, "Setting log levels = " << (logs ? logs : "<default>"));
OXEN_LOG(info, wallet_args::tr("Logging to: ") << log_path);
OXEN_LOG(error, "Failed to deserialize message: " << e.what());
OXEN_LOG(err, "POST request to Bitmessage failed: " << e.what());
OXEN_LOG(trace, "Checking filename: " << filename);
OXEN_LOG(trace, "Found wallet: " << filename);
// OXEN_LOG(trace, __FUNCTION__ << ": new block. height: " << height);
OXEN_LOG(trace, __FUNCTION__ << ": money received." << (blink ? "blink: " : "height: ") << height
OXEN_LOG(trace, __FUNCTION__ << ": unconfirmed money received. height:  " << height
OXEN_LOG(trace, __FUNCTION__ << ": money spent. height:  " << height
OXEN_LOG(info, __FUNCTION__ << " finished");
OXEN_LOG(trace, "wallet_path: " << path);
OXEN_LOG(trace, "keys_file_exists: " << std::boolalpha << keys_file_exists << std::noboolalpha
OXEN_LOG(err, "Error creating wallet: " << e.what());
OXEN_LOG(trace, "wallet_path: " << path);
OXEN_LOG(trace, "keys_file_exists: " << std::boolalpha << keys_file_exists << std::noboolalpha
OXEN_LOG(err, "Error creating view only wallet: " << e.what());
OXEN_LOG(err, "Error opening wallet: " << e.what());
OXEN_LOG(err, "Error closing wallet: " << e.what());
OXEN_LOG(err, "Error saving wallet: " << e.what());
OXEN_LOG(err, "Error sending import wallet request: " << e.what());
OXEN_LOG(err, __FUNCTION__ << ": " << err);
OXEN_LOG(err, __FUNCTION__ << ": " << err);
OXEN_LOG(trace, __FUNCTION__ << ": Refreshing asynchronously..");
OXEN_LOG(err, __FUNCTION__<< ": invalid refresh interval " << millis
OXEN_LOG(err, "Error exporting key images: " << e.what());
OXEN_LOG(debug, "Signed key images imported to height " << height << ", "
OXEN_LOG(err, "Error exporting key images: " << e.what());
OXEN_LOG(err, "Error getting subaddress label: " << e.what());
OXEN_LOG(err, "Error setting subaddress label: " << e.what());
OXEN_LOG(err, "Error on generating multisig info: " << e.what());
OXEN_LOG(err, "Error on making multisig wallet: " << e.what());
OXEN_LOG(err, "Error on exchanging multisig keys: " << e.what());
OXEN_LOG(err, "Error on finalizing multisig wallet creation: " << e.what());
OXEN_LOG(err, "Error on exporting multisig images: " << e.what());
OXEN_LOG(err, "Error on importing multisig images: " << e.what());
OXEN_LOG(err, "Error on checking for partial multisig key images: " << e.what());
OXEN_LOG(err, "Error on restoring multisig transaction: " << e.what());
OXEN_LOG(trace, __FUNCTION__ << ": starting refresh thread");
OXEN_LOG(trace, __FUNCTION__ << ": waiting for refresh...");
OXEN_LOG(trace, __FUNCTION__ << ": refresh lock acquired...");
OXEN_LOG(trace, __FUNCTION__ << ": m_refreshEnabled: " << m_refreshEnabled);
OXEN_LOG(trace, __FUNCTION__ << ": m_status: " << st.first << ": " << st.second);
OXEN_LOG(trace, __FUNCTION__ << ": m_refreshShouldRescan: " << m_refreshShouldRescan);
OXEN_LOG(trace, __FUNCTION__ << ": refreshing...");
OXEN_LOG(trace, __FUNCTION__ << ": refresh thread stopped");
OXEN_LOG(trace, __FUNCTION__ << ": doRefresh, rescan = "<<rescan);
OXEN_LOG(trace, __FUNCTION__ << ": skipping refresh - daemon is not synced");
OXEN_LOG(debug, __FUNCTION__ << ": refresh started/resumed...");
OXEN_LOG(debug, __FUNCTION__ << ": refresh paused...");
OXEN_LOG(debug, __FUNCTION__ << ":New Wallet - fast refresh until " << daemonBlockChainHeight());
OXEN_LOG(debug, __FUNCTION__ << ": Rebuilding wallet cache, fast refresh until block " << w->get_refresh_from_block_height());
OXEN_LOG(err, __FUNCTION__ << " error: " << e.what());
OXEN_LOG(error, "error: " << e.what());
OXEN_LOG(err, "setLabel: " << e.what());
OXEN_LOG(debug, "Deleting address book row " << rowId);
OXEN_LOG(info, __FUNCTION__ << ": Unconfirmed payment found " << pd.m_amount);
OXEN_LOG(trace, "m_pending_tx size: " << m_pending_tx.size());
else        OXEN_LOG(warn, "CHECKPOINT FAILED FOR HEIGHT " << height << ". EXPECTED HASH " << block_hash << "GIVEN HASH: " << hash);
OXEN_LOG(error, "Error loading checkpoints from " << json_hashfile_fullpath);
OXEN_LOG(error, "Get block checkpoint from DB failed at height: " << height << ", what = " << e.what());
OXEN_LOG(error, "Failed to add checkpoint with hash: " << checkpoint.block_hash << " at height: " << checkpoint.height << ", what = " << e.what());
OXEN_LOG(error, "Pruning block checkpoint on block added failed non-trivially at height: " << m_last_cull_height << ", what = " << e.what());
OXEN_LOG(error, "Remove block checkpoint on detach failed non-trivially at height: " << delete_height << ", what = " << e.what());
OXEN_LOG(trace, "null tx_hash_ptr - needed to compute: " << tx_hash);
OXEN_LOG(trace, "BlockchainDB_SQLITE::" << __func__);
OXEN_LOG(trace, "BlockchainDB_SQLITE::" << __func__);
OXEN_LOG(trace, "BlockchainDB_SQLITE::" << __func__);
OXEN_LOG(trace, "BlockchainDB_SQLITE::" << __func__ << " Called with new height: " << new_height);
OXEN_LOG(trace, "BlockchainDB_SQLITE::" << __func__ << " Called with height: " << height + 1);
OXEN_LOG(trace, "BlockchainDB_SQLITE::" << __func__ << " Called with height: " << height - 1);
OXEN_LOG(trace, "BlockchainDB_SQLITE::" << __func__);
OXEN_LOG(trace, "BlockchainDB_SQLITE::" << __func__);
OXEN_LOG(error, "tried to subtract payment from an address that doesn't exist: " << address_str);
OXEN_LOG(trace, "BlockchainDB_SQLITE::" << __func__);
OXEN_LOG(error, "Invalid address returned from batching database: " << address);
OXEN_LOG(trace, "BlockchainDB_SQLITE::" << __func__);
OXEN_LOG(trace, "BlockchainDB_SQLITE::" << __func__);
OXEN_LOG(trace, "BlockchainDB_SQLITE::" << __func__);
OXEN_LOG(trace, "BlockchainDB_SQLITE::" << __func__ << " called on height: " << block_height);
OXEN_LOG(trace, "BlockchainDB_SQLITE::" << __func__ << " called on height: " << block_height);
OXEN_LOG(trace, "BlockchainDB_SQLITE::" << __func__);
OXEN_LOG(trace, "BlockchainDB_SQLITE::" << __func__);
OXEN_LOG(trace, "BlockchainDB_SQLITE::" << __func__ << " Called with height: " << block_height);
OXEN_LOG(trace, "BlockchainDB_SQLITE::" << __func__ << " Called with height: " << block_height);
void commit() { try { if (m_batch) { m_db.batch_stop(); m_batch = false; } } catch (const std::exception &e) { OXEN_LOG(warn, "LockedTXN::commit filtering exception: " << e.what()); } }
void abort() { try { if (m_batch) { m_db.batch_abort(); m_batch = false; } } catch (const std::exception &e) { OXEN_LOG(warn, "LockedTXN::abort filtering exception: " << e.what()); } }
OXEN_LOG(warn, "Invalid stored type size in iterable_db: stored size (" << v.mv_size <<
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(error, "!! WARNING: Insufficient free space to extend database !!: " <<
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(debug, "DB map size:     " << mei.me_mapsize);
OXEN_LOG(debug, "Space used:      " << size_used);
OXEN_LOG(debug, "Space remaining: " << mei.me_mapsize - size_used);
OXEN_LOG(debug, "Size threshold:  " << threshold_size);
OXEN_LOG(debug, "Percent used: " << 100.*size_used/mei.me_mapsize << "  Percent threshold: " << 100.*resize_percent);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "[" << __func__ << "] " << "checking DB size");
OXEN_LOG(debug, "calculated batch size: " << threshold_size);
OXEN_LOG(debug, "increase size: " << increase_size);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(debug, "[" << __func__ << "] " << "m_height: " << m_height << "  block_start: " << block_start << "  block_stop: " << block_stop);
OXEN_LOG(debug, "average block size across recent " << m_cum_count << " blocks: " << avg_block_size);
OXEN_LOG(debug, "average block size across recent " << num_blocks_used << " blocks: " << avg_block_size);
OXEN_LOG(debug, "estimated average block size for batch: " << avg_block_size);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "m_height: " << m_height);
OXEN_LOG(trace, "parent_key: " << blk.prev_id);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(info, "tx has no outputs to remove: " << tx_hash);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
// OXEN_LOG(info, "tx_outputs[tx_hash] size: " << v.mv_size);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(info, "Pruning outputs for amount " << amount);
OXEN_LOG(info, num_elems << " outputs found");
OXEN_LOG(debug, "output id " << okp->output_id);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(warn, "Found existing LMDB files in " << old_files.u8string());
OXEN_LOG(warn, "Move " << BLOCKCHAINDATA_FILENAME << " and/or " << BLOCKCHAINDATA_LOCK_FILENAME << " to " << filename << ", or delete them, and then restart");
OXEN_LOG(info, "LMDB memory map size: " << cur_mapsize);
OXEN_LOG(debug, "Setting m_height to: " << db_stats.ms_entries);
OXEN_LOG(warn, "Existing lmdb database was made by a later version (" << db_version << "). We don't know how it will change yet.");
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(info, "switching safe mode " << (onoff ? "on" : "off"));
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(error, "Failed to remove " << filename << ": " << e.what());
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(warn, "Already pruned at height " << block_height << "/" << blockchain_height);
OXEN_LOG(debug, "Pruning at height " << block_height << "/" << blockchain_height);
OXEN_LOG(error, "Transaction not found in prunable tip table for height " << block_height << "/" << blockchain_height <<
OXEN_LOG(error, "Prunable data found for pruned height " << block_height << "/" << blockchain_height <<
OXEN_LOG(warn, "Already pruned at height " << block_height << "/" << blockchain_height);
OXEN_LOG(debug, "Pruning at height " << block_height << "/" << blockchain_height);
OXEN_LOG(error, "Prunable data not found for unpruned height " << block_height << "/" << blockchain_height <<
OXEN_LOG(info, (mode == prune_mode_check ? "Checked" : "Pruned") << " blockchain in " <<
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "Block with hash " << tools::type_to_hex(h) << " not found in db");
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__ << "  height: " << height);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(info, "transaction with hash " << tools::type_to_hex(h) << " not found in db");
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(info, "transaction with hash " << tools::type_to_hex(h) << " not found in db");
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(info, "batch transactions " << (m_batch_transactions ? "enabled" : "disabled"));
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(warn, "Unexpected pre-calculated maximum number of bytes: " << sizeof(result.data) << ", is insufficient to store signatures requiring: " << result.len << " bytes");
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(debug, "Partial result: " << outputs.size() << "/" << offsets.size());
OXEN_LOG(trace, "db3: " << db3);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "db3: " << db3);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB:: " << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB:: " << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
if (old_cumulative_diff != next_block.bi_diff) OXEN_LOG(warn, "Height: " << curr_height << " curr difficulty: " << old_cumulative_diff <<  ", new difficulty: " << next_block.bi_diff);
else                                           OXEN_LOG(debug, "Height: " << curr_height << " difficulty unchanged (" << old_cumulative_diff << ")");
OXEN_LOG(warn, "Something went wrong recalculating difficulty for block " << curr_height << e.what());
OXEN_LOG(warn, "Something went wrong in the pre-amble of recalculating difficulty for block: " << e.what());
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(info, "Total number of blocks: " << m_height);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(trace, "BlockchainLMDB::" << __func__);
OXEN_LOG(error, "Failed to set journal mode to WAL: {}" << sqlite3_errstr(rc));
OXEN_LOG(error, "Failed to set synchronous mode to NORMAL: {}" << sqlite3_errstr(rc));
OXEN_LOG(err, "RPC error: " << e.to_string());
OXEN_LOG(err, "unknown transfer error: " << e.to_string());
OXEN_LOG(err, "Multisig error: " << e.to_string());
OXEN_LOG(err, "internal error: " << e.to_string());
OXEN_LOG(err, "unexpected error: " << e.what());
OXEN_LOG(err, "Error exporting multisig info: " << e.what());
OXEN_LOG(err, "unexpected error: " << e.what());
OXEN_LOG(warn, "Device reconnect failed: " << e.what());
OXEN_LOG(trace, "wallet_path: " << wallet_path);
OXEN_LOG(trace, "keys_file_exists: " << std::boolalpha << keys_file_exists << std::noboolalpha
OXEN_LOG(err, "RPC error: " << e.to_string());
OXEN_LOG(err, "refresh error: " << e.to_string());
OXEN_LOG(err, "internal error: " << e.to_string());
OXEN_LOG(err, "unexpected error: " << e.what());
OXEN_LOG(err, "RPC error: " << e.to_string());
OXEN_LOG(err, "unexpected error: " << e.what());
OXEN_LOG(err, "Error exporting key images: " << e.what());
OXEN_LOG(err, "Error exporting outputs: " << e.what());
bool Blockchain::is_within_compiled_block_hash_area(uint64_t height) const
{
#if defined(PER_BLOCK_CHECKPOINT)
  return height < m_blocks_hash_of_hashes.size() * HASH_OF_HASHES_STEP;
#else
  return false;
#endif
}

bool Blockchain::for_all_key_images(std::function<bool(const crypto::key_image&)> f) const
{
  return m_db->for_all_key_images(f);
}

bool Blockchain::for_blocks_range(const uint64_t& h1, const uint64_t& h2, std::function<bool(uint64_t, const crypto::hash&, const block&)> f) const
{
  return m_db->for_blocks_range(h1, h2, f);
}

bool Blockchain::for_all_transactions(std::function<bool(const crypto::hash&, const cryptonote::transaction&)> f, bool pruned) const
{
  return m_db->for_all_transactions(f, pruned);
}

bool Blockchain::for_all_outputs(std::function<bool(uint64_t amount, const crypto::hash &tx_hash, uint64_t height, size_t tx_idx)> f) const
{
  return m_db->for_all_outputs(f);
}

bool Blockchain::for_all_outputs(uint64_t amount, std::function<bool(uint64_t height)> f) const
{
  return m_db->for_all_outputs(amount, f);
}

void Blockchain::invalidate_block_template_cache()
{
  OXEN_LOG(debug, "Invalidating block template cache");
  m_btc_valid = false;
}

void Blockchain::cache_block_template(const block &b, const cryptonote::account_public_address &address, const std::string &nonce, const difficulty_type &diff, uint64_t height, uint64_t expected_reward, uint64_t pool_cookie)
{
  OXEN_LOG(debug, "Setting block template cache");
  m_btc = b;
  m_btc_address = address;
  m_btc_nonce = nonce;
  m_btc_height = height;
  m_btc_expected_reward = expected_reward;
  m_btc_pool_cookie = pool_cookie;
  m_btc_valid = true;
}
